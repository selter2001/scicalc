---
phase: 03-advanced-modes-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/calculator/ui/calculator_window.py
  - src/calculator/ui/display.py
  - src/calculator/controller/calculator_controller.py
  - src/calculator/config/constants.py
  - src/calculator/config/locale.py
  - tests/test_controller.py
autonomous: true

must_haves:
  truths:
    - "User can toggle between DEG and RAD angle modes via a visible segmented button"
    - "Current angle mode is clearly displayed on screen at all times"
    - "sin(30) in DEG mode returns 0.5, sin(30) in RAD mode returns a different value"
    - "User can type digits 0-9 from keyboard and they appear in the expression"
    - "User can type +, -, *, /, (, ), . from keyboard and they appear in the expression"
    - "Pressing Enter evaluates the expression (same as clicking =)"
    - "Pressing Backspace removes the last character (same as clicking backspace button)"
    - "Pressing Escape clears the expression (same as clicking C)"
    - "Ctrl+C copies the current result to system clipboard"
    - "Ctrl+V pastes clipboard content into the expression"
  artifacts:
    - path: "src/calculator/ui/display.py"
      provides: "DisplayPanel with angle mode CTkSegmentedButton (DEG/RAD)"
      contains: "CTkSegmentedButton"
    - path: "src/calculator/ui/calculator_window.py"
      provides: "Window-level keyboard bindings for all keys and clipboard"
      contains: "bind.*Return"
    - path: "src/calculator/controller/calculator_controller.py"
      provides: "Controller with angle mode handling, keyboard routing, and clipboard ops"
      contains: "set_angle_mode"
    - path: "src/calculator/config/locale.py"
      provides: "Polish strings for angle mode labels"
      contains: "ANGLE_MODE"
    - path: "src/calculator/config/constants.py"
      provides: "Keyboard mapping constants"
      contains: "KEYBOARD_"
    - path: "tests/test_controller.py"
      provides: "Tests for angle mode, keyboard input, and clipboard"
      contains: "test_angle_mode"
  key_links:
    - from: "src/calculator/ui/display.py"
      to: "src/calculator/controller/calculator_controller.py"
      via: "angle_mode_callback from DisplayPanel to controller.on_angle_mode_change"
      pattern: "angle_mode_callback"
    - from: "src/calculator/controller/calculator_controller.py"
      to: "src/calculator/logic/calculator.py"
      via: "self.engine.set_angle_mode() when user toggles DEG/RAD"
      pattern: "self\\.engine\\.set_angle_mode"
    - from: "src/calculator/ui/calculator_window.py"
      to: "src/calculator/controller/calculator_controller.py"
      via: "keyboard_callback from window bindings to controller methods"
      pattern: "keyboard_callback"
    - from: "src/calculator/ui/calculator_window.py"
      to: "system clipboard"
      via: "clipboard_clear/clipboard_append/clipboard_get for Ctrl+C/V"
      pattern: "clipboard_"
---

<objective>
Add angle mode toggle (DEG/RAD), full keyboard input support, and clipboard operations (Ctrl+C/V) to the existing calculator.

Purpose: Cover requirements MODE-04 (angle toggle), MODE-05 (angle display), MODE-06 (keyboard digits/operators), MODE-07 (Enter/Backspace/Escape), HIST-04 (copy result), HIST-05 (paste value). These are controller/window-level additions that don't change the overall layout structure.

Output: Modified display.py (angle mode widget), modified calculator_window.py (keyboard bindings + clipboard), modified calculator_controller.py (angle mode + keyboard routing), extended locale.py and constants.py with new strings/constants, extended test_controller.py with new tests.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-modes-history/03-RESEARCH.md
@src/calculator/ui/calculator_window.py
@src/calculator/ui/display.py
@src/calculator/controller/calculator_controller.py
@src/calculator/config/constants.py
@src/calculator/config/locale.py
@src/calculator/logic/calculator.py
@src/calculator/logic/evaluator.py
@tests/test_controller.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add angle mode toggle to display and wire through controller to engine</name>
  <files>
    src/calculator/ui/display.py
    src/calculator/controller/calculator_controller.py
    src/calculator/ui/calculator_window.py
    src/calculator/config/locale.py
    src/calculator/config/constants.py
  </files>
  <action>
    **1. Extend `src/calculator/config/locale.py`** -- Add Polish angle mode labels. Append these constants:

    ```python
    # Angle mode labels (display)
    ANGLE_DEG = "DEG"
    ANGLE_RAD = "RAD"
    ```

    **2. Extend `src/calculator/config/constants.py`** -- Add keyboard mapping constant. Append:

    ```python
    # Keyboard characters that map directly to expression tokens
    KEYBOARD_CHARS = "0123456789+-*/()."
    ```

    **3. Modify `src/calculator/ui/display.py`** -- Add a CTkSegmentedButton for DEG/RAD toggle below the result display.

    Changes to DisplayPanel:
    - Import `ANGLE_DEG, ANGLE_RAD` from locale.py
    - Import `ANGLE_MODE_DEGREES, ANGLE_MODE_RADIANS` from constants.py
    - Add `self.angle_mode_callback = None` attribute
    - After the result_label, create a CTkSegmentedButton:
      ```python
      self.angle_mode_selector = ctk.CTkSegmentedButton(
          self,
          values=[ANGLE_DEG, ANGLE_RAD],
          width=120,
          font=("Arial", 12),
          command=self._on_angle_mode_change
      )
      self.angle_mode_selector.set(ANGLE_DEG)
      self.angle_mode_selector.pack(anchor="w", padx=10, pady=(5, 5))
      ```
    - Add `set_angle_mode_callback(self, callback)` method that stores the callback
    - Add `_on_angle_mode_change(self, value)` method that maps "DEG" to ANGLE_MODE_DEGREES and "RAD" to ANGLE_MODE_RADIANS, then calls `self.angle_mode_callback(mode)` if callback is set
    - Add `get_result(self)` method that returns `self.result_var.get()` -- needed for clipboard copy

    **4. Modify `src/calculator/ui/calculator_window.py`** -- Add angle mode callback wiring and method to expose angle mode.

    Changes to CalculatorWindow:
    - Add `self.angle_mode_callback = None` attribute in __init__
    - Add `set_angle_mode_callback(self, callback)` method:
      ```python
      def set_angle_mode_callback(self, callback):
          self.angle_mode_callback = callback
          self.display.set_angle_mode_callback(callback)
      ```
    - Add `get_result(self)` convenience method that returns `self.display.get_result()`

    **5. Modify `src/calculator/controller/calculator_controller.py`** -- Wire angle mode through controller.

    Changes to CalculatorController.__init__:
    - Add `self.view.set_angle_mode_callback(self.on_angle_mode_change)` after existing callback wiring

    Add new method:
    ```python
    def on_angle_mode_change(self, mode):
        """Handle angle mode change from DEG/RAD toggle."""
        self.engine.set_angle_mode(mode)
    ```

    Note: The existing `on_mode_change` handles basic/scientific toggle. This new `on_angle_mode_change` handles DEG/RAD. They are separate concerns -- do not merge them.
  </action>
  <verify>
    Run existing tests to confirm no regressions:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/ -v --tb=short
    ```
    All 139 existing tests must still pass.

    Verify angle mode imports work:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    from src.calculator.config.locale import ANGLE_DEG, ANGLE_RAD
    from src.calculator.config.constants import KEYBOARD_CHARS
    print('ANGLE_DEG:', ANGLE_DEG)
    print('ANGLE_RAD:', ANGLE_RAD)
    print('KEYBOARD_CHARS:', KEYBOARD_CHARS)
    print('All new constants OK')
    "
    ```
  </verify>
  <done>
    DisplayPanel has a visible DEG/RAD CTkSegmentedButton below the result. Toggling it calls controller.on_angle_mode_change which calls engine.set_angle_mode(). The angle mode widget is always visible (MODE-05). Toggling changes the engine's trig behavior (MODE-04). All 139 existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add keyboard bindings, clipboard operations, and tests for all new features</name>
  <files>
    src/calculator/ui/calculator_window.py
    src/calculator/controller/calculator_controller.py
    tests/test_controller.py
  </files>
  <action>
    **1. Modify `src/calculator/ui/calculator_window.py`** -- Add window-level keyboard bindings and clipboard operations.

    Add a `self.keyboard_callback = None` attribute in __init__.

    Add `set_keyboard_callback(self, callback)` method that stores the callback.

    Add `_bind_keyboard_shortcuts(self)` method, called at the END of __init__ (after all widgets are created):

    ```python
    def _bind_keyboard_shortcuts(self):
        """Bind all keyboard shortcuts at window level."""
        # Enter = calculate (same as =)
        self.bind("<Return>", lambda e: self._on_key("="))

        # Escape = clear (same as C)
        self.bind("<Escape>", lambda e: self._on_key("C"))

        # Backspace = delete last char
        self.bind("<BackSpace>", lambda e: self._on_key("\u232b"))

        # Ctrl+C = copy result to clipboard
        self.bind("<Control-c>", lambda e: self._handle_copy())

        # Ctrl+V = paste from clipboard
        self.bind("<Control-v>", lambda e: self._handle_paste())

        # Number and operator keys -- use lambda default param to avoid closure bug
        for char in KEYBOARD_CHARS:
            self.bind(char, lambda e, c=char: self._on_key(c))
    ```

    Import KEYBOARD_CHARS from constants at the top of the file.

    Add `_on_key(self, label)` method:
    ```python
    def _on_key(self, label):
        """Route keyboard input through button callback."""
        if self.button_callback:
            self.button_callback(label)
    ```

    Add `_handle_copy(self)` method:
    ```python
    def _handle_copy(self):
        """Copy current result to system clipboard."""
        result_text = self.display.get_result()
        if result_text:
            self.clipboard_clear()
            self.clipboard_append(result_text)
        return "break"  # Prevent default Ctrl+C behavior
        # Note: lambda binding `lambda e: self._handle_copy()` propagates
        # the "break" return value, which prevents tkinter's default Ctrl+C
    ```

    Add `_handle_paste(self)` method:
    ```python
    def _handle_paste(self):
        """Paste clipboard content into expression."""
        try:
            clipboard_text = self.clipboard_get()
            if clipboard_text and self.button_callback:
                # Strip whitespace before validation (trailing spaces from copy)
                clipboard_text = clipboard_text.strip()
                # Validate: only paste numeric/operator content
                valid_chars = set("0123456789+-*/().eE")
                if clipboard_text and all(c in valid_chars for c in clipboard_text):
                    self.button_callback(clipboard_text)
        except Exception:
            # Clipboard empty or contains non-text data -- ignore silently
            pass
        return "break"  # Prevent default Ctrl+V behavior
        # Note: lambda binding `lambda e: self._handle_paste()` propagates
        # the "break" return value, which prevents tkinter's default Ctrl+V
    ```

    IMPORTANT: The `return "break"` in _handle_copy and _handle_paste prevents tkinter's default handling of Ctrl+C/V which could interfere.

    Call `self._bind_keyboard_shortcuts()` at the end of __init__ in CalculatorWindow.

    **2. Modify `src/calculator/controller/calculator_controller.py`** -- Handle pasted multi-character strings.

    The existing `_append` method receives a `label` string. When paste sends a multi-character string like "3.14", this already works because `_append` just concatenates `token` to `self.expression`. The LABEL_TO_TOKEN lookup won't match a multi-char paste string, so it falls through to the default (the pasted string itself). No changes needed to _append for paste support.

    However, ensure the mock_view in __init__ also exposes set_angle_mode_callback. In the controller's __init__, add the `set_angle_mode_callback` call ONLY if the view has that method (for backward compatibility with tests that use simple mocks):

    Actually, the cleaner approach: just always call it. The test mock_view fixture will need updating (see Task 2 step 3).

    **3. Extend `tests/test_controller.py`** -- Add tests for angle mode, keyboard input, and clipboard.

    Add to the `mock_view` fixture:
    ```python
    view.set_angle_mode_callback = Mock()
    view.get_result = Mock(return_value="42")
    ```

    Add these new test functions (at module level, using the existing fixture pattern):

    ```python
    # --- Angle mode tests ---

    def test_angle_mode_change_to_radians(controller, mock_view):
        """Switching to RAD sets engine to radians mode."""
        controller.on_angle_mode_change("radians")
        # Verify by calculating sin(pi/2) which should be ~1 in radians
        controller.on_button_click("sin")
        controller.on_button_click("(")
        # Build expression for pi/2 -- use "pi" constant
        controller.expression = "sin(pi/2)"
        controller.on_button_click("=")
        last_result = mock_view.update_result.call_args[0][0]
        assert last_result == "1"

    def test_angle_mode_change_to_degrees(controller, mock_view):
        """Switching to DEG sets engine to degrees mode."""
        controller.on_angle_mode_change("degrees")
        controller.expression = "sin(30)"
        controller.on_button_click("=")
        last_result = mock_view.update_result.call_args[0][0]
        assert last_result == "0.5"

    def test_angle_mode_deg_vs_rad_different_results(controller, mock_view):
        """Same expression gives different results in DEG vs RAD."""
        # DEG mode (default)
        controller.on_angle_mode_change("degrees")
        controller.expression = "sin(30)"
        controller.on_button_click("=")
        deg_result = mock_view.update_result.call_args[0][0]

        # RAD mode
        controller.on_angle_mode_change("radians")
        controller.expression = "sin(30)"
        controller.error_state = False
        controller.on_button_click("=")
        rad_result = mock_view.update_result.call_args[0][0]

        assert deg_result != rad_result
        assert deg_result == "0.5"  # sin(30 degrees) = 0.5

    # --- Keyboard input tests ---

    def test_keyboard_digit_input(controller, mock_view):
        """Keyboard digit is routed through on_button_click."""
        # Simulate what the window does when key is pressed
        controller.on_button_click("7")
        assert controller.expression == "7"
        mock_view.update_expression.assert_called_with("7")

    def test_keyboard_operator_input(controller, mock_view):
        """Keyboard operator is routed through on_button_click."""
        controller.on_button_click("5")
        controller.on_button_click("+")
        controller.on_button_click("3")
        assert controller.expression == "5+3"

    def test_keyboard_enter_calculates(controller, mock_view):
        """Enter key (mapped to =) calculates expression."""
        controller.expression = "2+3"
        controller.on_button_click("=")  # Enter maps to "="
        mock_view.update_result.assert_called_with("5")

    def test_keyboard_escape_clears(controller, mock_view):
        """Escape key (mapped to C) clears expression."""
        controller.expression = "123"
        controller.on_button_click("C")  # Escape maps to "C"
        assert controller.expression == ""
        mock_view.update_expression.assert_called_with("")
        mock_view.update_result.assert_called_with("0")

    def test_keyboard_backspace_deletes(controller, mock_view):
        """Backspace key removes last character."""
        controller.expression = "123"
        controller.on_button_click("\u232b")
        assert controller.expression == "12"

    def test_keyboard_parentheses(controller, mock_view):
        """Keyboard parentheses work in expressions."""
        controller.on_button_click("(")
        controller.on_button_click("2")
        controller.on_button_click("+")
        controller.on_button_click("3")
        controller.on_button_click(")")
        controller.on_button_click("*")
        controller.on_button_click("4")
        assert controller.expression == "(2+3)*4"
        controller.on_button_click("=")
        mock_view.update_result.assert_called_with("20")

    def test_paste_numeric_string(controller, mock_view):
        """Pasting a numeric string appends it to expression."""
        controller.on_button_click("3.14")  # Simulates paste
        assert controller.expression == "3.14"
    ```

    IMPORTANT: Keyboard tests work by verifying that the controller's on_button_click handles the same labels that the window's keyboard bindings produce. The window maps keys to labels (Enter->"=", Escape->"C", BackSpace->backspace symbol, digits->themselves) and calls button_callback. We test this at the controller level since the window bindings are simple lambda pass-throughs.
  </action>
  <verify>
    Run the full test suite:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/ -v --tb=short
    ```
    All tests must pass -- both the original 139 and the new angle mode + keyboard tests (expect ~150+ total).

    Verify keyboard binding code is syntactically correct:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    import ast
    with open('src/calculator/ui/calculator_window.py') as f:
        ast.parse(f.read())
    print('calculator_window.py parses OK')
    with open('src/calculator/controller/calculator_controller.py') as f:
        ast.parse(f.read())
    print('calculator_controller.py parses OK')
    with open('src/calculator/ui/display.py') as f:
        ast.parse(f.read())
    print('display.py parses OK')
    "
    ```

    Verify new test count:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/ --co -q | tail -1
    ```
    Should show 150+ tests collected.
  </verify>
  <done>
    Keyboard bindings active at window level: digits 0-9, operators +-*/()., Enter (=), Backspace (delete), Escape (clear), Ctrl+C (copy result), Ctrl+V (paste value). Lambda closure pattern used correctly for key loops. Clipboard uses tkinter clipboard_get/clipboard_append with TclError handling. Paste validates content is numeric before inserting. All new features tested. Full test suite passes (150+ tests, zero regressions).
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `python -m pytest tests/ -v` -- ALL tests pass (150+)
2. Launch app and check DEG/RAD toggle is visible below the result display
3. Toggle to RAD, type sin(30), press = -- result is NOT 0.5
4. Toggle to DEG, type sin(30), press = -- result IS 0.5
5. Type "2+3" using keyboard, press Enter -- result shows "5"
6. Press Escape -- display clears to 0
7. Type "123" using keyboard, press Backspace -- shows "12"
8. Calculate something, press Ctrl+C -- result copied to clipboard (verify by pasting elsewhere)
9. Copy "3.14" to clipboard from another app, press Ctrl+V in calculator -- "3.14" appears in expression
10. All keyboard input works regardless of which widget has focus (window-level bindings)
</verification>

<success_criteria>
- MODE-04: DEG/RAD toggle via CTkSegmentedButton changes engine angle mode
- MODE-05: Angle mode selector always visible on display panel
- MODE-06: Digits 0-9 and operators +-*/().  work from keyboard
- MODE-07: Enter=calculate, Backspace=delete, Escape=clear
- HIST-04: Ctrl+C copies current result to system clipboard
- HIST-05: Ctrl+V pastes valid numeric content into expression
- Angle mode integration verified: sin(30) DEG=0.5, RAD!=0.5
- All 150+ tests pass (zero regressions from 139 baseline)
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-modes-history/03-01-SUMMARY.md`
</output>
