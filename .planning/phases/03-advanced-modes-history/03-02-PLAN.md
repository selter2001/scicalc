---
phase: 03-advanced-modes-history
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/calculator/ui/history_panel.py
  - src/calculator/ui/calculator_window.py
  - src/calculator/controller/calculator_controller.py
  - src/calculator/config/constants.py
  - src/calculator/config/locale.py
  - tests/test_controller.py
autonomous: true

must_haves:
  truths:
    - "A side panel on the right displays a list of previous calculations as 'expression = result' entries"
    - "After each successful calculation, a new entry appears at the top/bottom of the history list"
    - "Clicking a history entry inserts that entry's result into the current expression on the display"
    - "User can click a 'clear history' button and all history entries disappear"
    - "Calculator remains responsive after many calculations (history limited to MAX_HISTORY_ENTRIES)"
    - "Window is wider to accommodate the history panel alongside the calculator"
  artifacts:
    - path: "src/calculator/ui/history_panel.py"
      provides: "HistoryPanel(CTkScrollableFrame) with add_entry, clear_history, click-to-recall"
      contains: "class HistoryPanel"
    - path: "src/calculator/ui/calculator_window.py"
      provides: "2-column layout: calculator left, history panel right"
      contains: "history_panel"
    - path: "src/calculator/controller/calculator_controller.py"
      provides: "History list management, add-on-calculate, recall-on-click, clear"
      contains: "self.history"
    - path: "src/calculator/config/constants.py"
      provides: "History and layout constants (MAX_HISTORY, wider geometry)"
      contains: "MAX_HISTORY"
    - path: "src/calculator/config/locale.py"
      provides: "Polish strings for history panel (header, clear button, empty message)"
      contains: "HIST_"
    - path: "tests/test_controller.py"
      provides: "Tests for history add, recall, clear, and max limit"
      contains: "test_history"
  key_links:
    - from: "src/calculator/controller/calculator_controller.py"
      to: "src/calculator/ui/history_panel.py"
      via: "controller calls view.add_history_entry() after successful calculation"
      pattern: "add_history_entry"
    - from: "src/calculator/ui/history_panel.py"
      to: "src/calculator/controller/calculator_controller.py"
      via: "recall_callback from history click to controller.on_history_recall"
      pattern: "recall_callback"
    - from: "src/calculator/ui/calculator_window.py"
      to: "src/calculator/ui/history_panel.py"
      via: "HistoryPanel instantiated in window, placed in column 1 of grid"
      pattern: "HistoryPanel"
---

<objective>
Add a scrollable history side panel that shows previous calculations, supports click-to-recall, and can be cleared.

Purpose: Cover requirements HIST-01 (side panel with calculation list), HIST-02 (click entry to recall result), HIST-03 (clear history). This is the final feature set for Phase 3, completing the advanced calculator experience.

Output: New history_panel.py module, modified calculator_window.py (2-column layout with history), modified calculator_controller.py (history state management), extended constants.py and locale.py, extended test_controller.py.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-advanced-modes-history/03-RESEARCH.md
@.planning/phases/03-advanced-modes-history/03-01-SUMMARY.md
@src/calculator/ui/calculator_window.py
@src/calculator/controller/calculator_controller.py
@src/calculator/config/constants.py
@src/calculator/config/locale.py
@tests/test_controller.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HistoryPanel component and add Polish locale strings</name>
  <files>
    src/calculator/ui/history_panel.py
    src/calculator/config/locale.py
    src/calculator/config/constants.py
  </files>
  <action>
    **1. Extend `src/calculator/config/locale.py`** -- Add Polish history panel strings. Append:

    ```python
    # History panel
    HIST_TITLE = "Historia"
    HIST_CLEAR = "Wyczysc historie"
    HIST_EMPTY = "Brak historii"
    ```

    **2. Extend `src/calculator/config/constants.py`** -- Add history and layout constants. Append:

    ```python
    # History
    MAX_HISTORY_ENTRIES = 100

    # History panel styling
    HISTORY_PANEL_WIDTH = 250
    FONT_HISTORY_TITLE = 14
    FONT_HISTORY_ENTRY = 13

    # Updated window geometry to accommodate history panel
    WINDOW_WITH_HISTORY_WIDTH = 700
    WINDOW_WITH_HISTORY_MIN_WIDTH = 650
    ```

    **3. Create `src/calculator/ui/history_panel.py`** -- Scrollable history panel:

    ```python
    """Scrollable history panel showing past calculations."""
    import customtkinter as ctk
    from src.calculator.config.locale import HIST_TITLE, HIST_CLEAR, HIST_EMPTY
    from src.calculator.config.constants import (
        HISTORY_PANEL_WIDTH,
        FONT_HISTORY_TITLE,
        FONT_HISTORY_ENTRY
    )


    class HistoryPanel(ctk.CTkFrame):
        """
        Side panel displaying calculation history with click-to-recall.
        Uses CTkScrollableFrame for the entry list and a fixed header/clear button.
        """

        def __init__(self, master, **kwargs):
            super().__init__(master, **kwargs)

            self.recall_callback = None
            self.entry_widgets = []  # List of entry frame widgets

            # Configure grid: header (row 0), scrollable list (row 1), clear button (row 2)
            self.grid_rowconfigure(0, weight=0)
            self.grid_rowconfigure(1, weight=1)
            self.grid_rowconfigure(2, weight=0)
            self.grid_columnconfigure(0, weight=1)

            # Header
            self.header_label = ctk.CTkLabel(
                self,
                text=HIST_TITLE,
                font=ctk.CTkFont(size=FONT_HISTORY_TITLE, weight="bold"),
                anchor="w"
            )
            self.header_label.grid(row=0, column=0, padx=10, pady=(10, 5), sticky="ew")

            # Scrollable frame for entries
            self.scrollable_frame = ctk.CTkScrollableFrame(
                self,
                width=HISTORY_PANEL_WIDTH,
                fg_color="transparent"
            )
            self.scrollable_frame.grid(row=1, column=0, padx=5, pady=0, sticky="nsew")

            # Empty state message
            self.empty_label = ctk.CTkLabel(
                self.scrollable_frame,
                text=HIST_EMPTY,
                text_color="gray50",
                font=ctk.CTkFont(size=FONT_HISTORY_ENTRY)
            )
            self.empty_label.pack(pady=20)

            # Clear history button -- routes through _on_clear to notify controller
            self.clear_callback = None
            self.clear_button = ctk.CTkButton(
                self,
                text=HIST_CLEAR,
                command=self._on_clear,
                height=30,
                font=ctk.CTkFont(size=12),
                fg_color="#505050",
                hover_color="#606060"
            )
            self.clear_button.grid(row=2, column=0, padx=10, pady=(5, 10), sticky="ew")

        def set_recall_callback(self, callback):
            """Set callback for when a history entry is clicked. Callback receives result string."""
            self.recall_callback = callback

        def set_clear_callback(self, callback):
            """Set callback for when clear button is clicked. Notifies controller to clear data."""
            self.clear_callback = callback

        def _on_clear(self):
            """Handle clear button click -- clear UI and notify controller."""
            self.clear_history()
            if self.clear_callback:
                self.clear_callback()

        def add_entry(self, expression, result):
            """
            Add a calculation to the history display.
            Shows as 'expression = result' with click-to-recall on the result.
            New entries appear at the top (most recent first).
            """
            # Remove empty state message if present
            if self.empty_label.winfo_exists():
                self.empty_label.destroy()

            # Create entry frame
            entry_frame = ctk.CTkFrame(self.scrollable_frame, fg_color="transparent")

            # Expression text (smaller, gray)
            expr_label = ctk.CTkLabel(
                entry_frame,
                text=expression,
                font=ctk.CTkFont(size=FONT_HISTORY_ENTRY - 1),
                text_color="gray60",
                anchor="w",
                cursor="hand2"
            )
            expr_label.pack(fill="x", padx=5)

            # Result text (normal, white, clickable)
            result_label = ctk.CTkLabel(
                entry_frame,
                text=f"= {result}",
                font=ctk.CTkFont(size=FONT_HISTORY_ENTRY, weight="bold"),
                anchor="w",
                cursor="hand2"
            )
            result_label.pack(fill="x", padx=5)

            # Separator line
            separator = ctk.CTkFrame(entry_frame, height=1, fg_color="gray30")
            separator.pack(fill="x", padx=5, pady=(3, 0))

            # Bind click on both labels to recall -- use default param to capture result
            for widget in [expr_label, result_label]:
                widget.bind("<Button-1>", lambda e, r=result: self._on_entry_click(r))

            # Pack at bottom (chronological order: oldest at top, newest at bottom)
            entry_frame.pack(fill="x", pady=2)
            self.entry_widgets.append(entry_frame)

        def _on_entry_click(self, result):
            """Handle click on a history entry."""
            if self.recall_callback:
                self.recall_callback(result)

        def clear_history(self):
            """Remove all history entries and show empty state."""
            for widget in self.entry_widgets:
                widget.destroy()
            self.entry_widgets.clear()

            # Restore empty state message
            self.empty_label = ctk.CTkLabel(
                self.scrollable_frame,
                text=HIST_EMPTY,
                text_color="gray50",
                font=ctk.CTkFont(size=FONT_HISTORY_ENTRY)
            )
            self.empty_label.pack(pady=20)
    ```

    Note: `add_entry` uses chronological order (oldest at top, newest at bottom) — natural for a calculation log.
  </action>
  <verify>
    Verify the new module is importable:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    from src.calculator.ui.history_panel import HistoryPanel
    from src.calculator.config.locale import HIST_TITLE, HIST_CLEAR, HIST_EMPTY
    from src.calculator.config.constants import MAX_HISTORY_ENTRIES, HISTORY_PANEL_WIDTH
    print('HistoryPanel importable')
    print('HIST_TITLE:', HIST_TITLE)
    print('MAX_HISTORY_ENTRIES:', MAX_HISTORY_ENTRIES)
    print('All history constants OK')
    "
    ```
    Must print without errors.
  </verify>
  <done>
    HistoryPanel component created as CTkFrame containing a CTkScrollableFrame for entries, a header label ("Historia"), a clear button ("Wyczysc historie"), and an empty state message. Each entry shows expression (gray) and result (bold, clickable). Click triggers recall_callback with the result string. clear_history() destroys all entries and restores empty message. Polish locale strings and history constants added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate history panel into window layout and controller, add tests</name>
  <files>
    src/calculator/ui/calculator_window.py
    src/calculator/controller/calculator_controller.py
    src/calculator/ui/history_panel.py
    tests/test_controller.py
  </files>
  <action>
    **1. Modify `src/calculator/ui/calculator_window.py`** -- Restructure to 2-column layout with history panel on the right.

    Import HistoryPanel:
    ```python
    from src.calculator.ui.history_panel import HistoryPanel
    ```

    Import new constants:
    ```python
    from src.calculator.config.constants import (
        WINDOW_MIN_WIDTH,
        WINDOW_MIN_HEIGHT,
        WINDOW_DEFAULT_GEOMETRY,
        WINDOW_WITH_HISTORY_WIDTH,
        WINDOW_WITH_HISTORY_MIN_WIDTH,
        HISTORY_PANEL_WIDTH
    )
    ```

    Restructure __init__ layout:

    The current layout is a single column with mode_selector (row 0), display (row 1), button_panel (row 2), all in column 0.

    New layout uses a LEFT frame (column 0) for the calculator and a history panel (column 1) on the right:

    ```python
    def __init__(self):
        super().__init__()

        # Window configuration -- wider to fit history panel
        self.title(WINDOW_TITLE)
        self.geometry(f"{WINDOW_WITH_HISTORY_WIDTH}x600")
        self.minsize(WINDOW_WITH_HISTORY_MIN_WIDTH, WINDOW_MIN_HEIGHT)

        # Main grid: calculator (col 0, expand) | history (col 1, fixed width)
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=0)
        self.grid_rowconfigure(0, weight=1)

        # Left frame: contains mode selector, display, buttons (existing layout)
        self.calc_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.calc_frame.grid(row=0, column=0, padx=(10, 5), pady=10, sticky="nsew")
        self.calc_frame.grid_rowconfigure(0, weight=0)  # mode selector
        self.calc_frame.grid_rowconfigure(1, weight=0)  # display
        self.calc_frame.grid_rowconfigure(2, weight=1)  # buttons
        self.calc_frame.grid_columnconfigure(0, weight=1)

        # Mode selector (inside calc_frame)
        self.mode_selector = ctk.CTkSegmentedButton(
            self.calc_frame,
            values=[BTN_MODE_BASIC, BTN_MODE_SCIENTIFIC],
            command=self._on_mode_change
        )
        self.mode_selector.set(BTN_MODE_BASIC)
        self.mode_selector.grid(row=0, column=0, padx=10, pady=10, sticky="ew")

        # Display panel (inside calc_frame)
        self.display = DisplayPanel(self.calc_frame)
        self.display.grid(row=1, column=0, padx=10, pady=10, sticky="ew")

        # Button panel (inside calc_frame)
        self.button_panel = ButtonPanel(self.calc_frame)
        self.button_panel.grid(row=2, column=0, padx=10, pady=(0, 10), sticky="nsew")

        # Right side: History panel
        self.history_panel = HistoryPanel(self)
        self.history_panel.grid(row=0, column=1, padx=(5, 10), pady=10, sticky="nsew")

        # Callbacks (set by controller)
        self.button_callback = None
        self.mode_callback = None
        self.angle_mode_callback = None

        # Bind keyboard shortcuts (from Plan 03-01)
        self._bind_keyboard_shortcuts()
    ```

    IMPORTANT: The mode selector, display, and button panel now go into `self.calc_frame` instead of directly onto `self`. Update ALL references:
    - `self.mode_selector` parent: `self.calc_frame` (not `self`)
    - `self.display` parent: `self.calc_frame` (not `self`)
    - `self.button_panel` parent: `self.calc_frame` (not `self`)

    The existing methods (_on_mode_change, set_button_callback, set_mode_callback, update_expression, update_result, set_angle_mode_callback, get_result, _bind_keyboard_shortcuts, _on_key, _handle_copy, _handle_paste) do NOT need changes because they reference self.display and self.button_panel which are still the same objects, just parented differently.

    Add convenience methods for history:
    ```python
    def add_history_entry(self, expression, result):
        """Add entry to history panel."""
        self.history_panel.add_entry(expression, result)

    def set_history_recall_callback(self, callback):
        """Set callback for history entry clicks."""
        self.history_panel.set_recall_callback(callback)

    def clear_history(self):
        """Clear all history entries."""
        self.history_panel.clear_history()
    ```

    **2. Modify `src/calculator/controller/calculator_controller.py`** -- Add history state management.

    Import MAX_HISTORY_ENTRIES:
    ```python
    from src.calculator.config.constants import MAX_HISTORY_ENTRIES
    ```

    Add to __init__:
    ```python
    self.history = []  # List of {"expression": str, "result": str}

    # Wire history recall callback
    self.view.set_history_recall_callback(self.on_history_recall)
    ```

    Modify `_calculate` method -- after a successful calculation, add to history:
    ```python
    def _calculate(self):
        """Evaluate current expression."""
        if not self.expression:
            return

        result = self.engine.calculate(self.expression)

        if result["success"]:
            self.last_result = result["result"]
            self.view.update_result(self.last_result)
            self.error_state = False

            # Add to history
            self.history.append({
                "expression": self.expression,
                "result": self.last_result
            })
            # Enforce max history limit
            if len(self.history) > MAX_HISTORY_ENTRIES:
                self.history.pop(0)
            # Update history panel in view
            self.view.add_history_entry(self.expression, self.last_result)
        else:
            self.view.update_result(result["error"])
            self.error_state = True
    ```

    Add `on_history_recall` method:
    ```python
    def on_history_recall(self, result):
        """Handle click on history entry -- insert result into expression."""
        if self.error_state:
            self._clear()
        self.expression += result
        self.view.update_expression(self.expression)
    ```

    Add `clear_history` method:
    ```python
    def clear_history(self):
        """Clear all history entries."""
        self.history.clear()
        self.view.clear_history()
    ```

    The HistoryPanel's clear button uses the `_on_clear` → `clear_callback` pattern (already set up in Task 1). Wire it through the window and controller:

    In CalculatorWindow, add:
    ```python
    def set_history_clear_callback(self, callback):
        """Set callback for when clear history button is clicked."""
        self.history_panel.set_clear_callback(callback)
    ```

    In CalculatorController.__init__, add after the recall callback wiring:
    ```python
    self.view.set_history_clear_callback(self._on_history_cleared)
    ```

    Add to controller:
    ```python
    def _on_history_cleared(self):
        """Called when user clicks clear history button in UI. Clears data list."""
        self.history.clear()
    ```

    Flow: User clicks "Wyczysc historie" → HistoryPanel._on_clear() → clears UI widgets → calls clear_callback → controller._on_history_cleared() → clears data list.

    **3. Extend `tests/test_controller.py`** -- Add history tests.

    Update the `mock_view` fixture to include history methods:
    ```python
    view.add_history_entry = Mock()
    view.set_history_recall_callback = Mock()
    view.set_history_clear_callback = Mock()
    view.clear_history = Mock()
    ```

    Add these test functions:

    ```python
    # --- History tests ---

    def test_history_added_on_calculate(controller, mock_view):
        """Successful calculation adds entry to history."""
        controller.expression = "2+3"
        controller.on_button_click("=")
        assert len(controller.history) == 1
        assert controller.history[0]["expression"] == "2+3"
        assert controller.history[0]["result"] == "5"
        mock_view.add_history_entry.assert_called_once_with("2+3", "5")

    def test_history_not_added_on_error(controller, mock_view):
        """Failed calculation does NOT add to history."""
        controller.expression = "1/0"
        controller.on_button_click("=")
        assert len(controller.history) == 0
        mock_view.add_history_entry.assert_not_called()

    def test_history_multiple_entries(controller, mock_view):
        """Multiple calculations add multiple history entries."""
        controller.expression = "1+1"
        controller.on_button_click("=")
        controller.expression = "2*3"
        controller.on_button_click("=")
        controller.expression = "10-4"
        controller.on_button_click("=")
        assert len(controller.history) == 3
        assert controller.history[0]["result"] == "2"
        assert controller.history[1]["result"] == "6"
        assert controller.history[2]["result"] == "6"

    def test_history_recall_inserts_result(controller, mock_view):
        """Clicking history entry inserts result into expression."""
        controller.expression = "5+"
        controller.on_history_recall("42")
        assert controller.expression == "5+42"
        mock_view.update_expression.assert_called_with("5+42")

    def test_history_recall_clears_error_first(controller, mock_view):
        """Recalling from history while in error state clears error first."""
        controller.error_state = True
        controller.expression = "bad"
        controller.on_history_recall("7")
        assert controller.expression == "7"
        assert controller.error_state is False

    def test_history_max_limit(controller, mock_view):
        """History enforces MAX_HISTORY_ENTRIES limit."""
        from src.calculator.config.constants import MAX_HISTORY_ENTRIES
        for i in range(MAX_HISTORY_ENTRIES + 10):
            controller.expression = f"{i}+1"
            controller.on_button_click("=")
            controller.error_state = False  # Reset for next iteration
        assert len(controller.history) == MAX_HISTORY_ENTRIES
        # Oldest entries should have been popped
        assert controller.history[0]["expression"] != "0+1"

    def test_history_cleared_by_controller(controller, mock_view):
        """Controller clear_history empties both data and view."""
        controller.expression = "1+1"
        controller.on_button_click("=")
        controller.expression = "2+2"
        controller.on_button_click("=")
        assert len(controller.history) == 2

        controller._on_history_cleared()
        assert len(controller.history) == 0
    ```
  </action>
  <verify>
    Run full test suite:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/ -v --tb=short
    ```
    All tests must pass (expect ~165+ total including Plan 01 angle/keyboard tests + new history tests).

    Verify all files parse correctly:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    import ast
    for f in ['src/calculator/ui/history_panel.py', 'src/calculator/ui/calculator_window.py', 'src/calculator/controller/calculator_controller.py']:
        with open(f) as fh:
            ast.parse(fh.read())
        print(f'{f} parses OK')
    "
    ```

    Verify history panel is importable and integrated:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    from src.calculator.ui.history_panel import HistoryPanel
    from src.calculator.config.constants import MAX_HISTORY_ENTRIES, WINDOW_WITH_HISTORY_WIDTH
    print('HistoryPanel imported OK')
    print('MAX_HISTORY_ENTRIES:', MAX_HISTORY_ENTRIES)
    print('Window width:', WINDOW_WITH_HISTORY_WIDTH)
    "
    ```

    Verify test count:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/ --co -q | tail -1
    ```
    Should show 165+ tests.
  </verify>
  <done>
    HistoryPanel integrated into calculator window as a right-side panel. Window uses 2-column grid (calculator left, history right) with wider geometry. Controller manages history list (max 100 entries), adds entries on successful calculations, supports click-to-recall (inserts result into expression), and clears history when user clicks clear button. History panel shows "Historia" header, scrollable entries with expression+result, "Wyczysc historie" clear button, and "Brak historii" empty state. All 165+ tests pass (zero regressions).
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `python -m pytest tests/ -v` -- ALL tests pass (165+)
2. Launch app -- window is wider with history panel on the right side
3. History panel shows "Historia" header and "Brak historii" empty message
4. Calculate "2+3" -- history shows "2+3" and "= 5"
5. Calculate "sin(30)" -- history shows second entry
6. Click on "= 5" in history -- "5" is inserted into the current expression
7. Click "Wyczysc historie" button -- all history entries disappear, "Brak historii" shown again
8. Perform 5+ calculations rapidly -- all appear in history, scrollable
9. History panel does not break when window is resized
10. All Phase 3 features work together: keyboard input + angle mode + history
</verification>

<success_criteria>
- HIST-01: Side panel displays scrollable list of previous calculations with expression and result
- HIST-02: Clicking a history entry inserts the result into the current expression display
- HIST-03: Clear button removes all history entries and shows empty state
- History limited to 100 entries (MAX_HISTORY_ENTRIES)
- Window properly accommodates history panel with 2-column layout
- All Polish labels (Historia, Wyczysc historie, Brak historii) display correctly
- All 165+ tests pass (zero regressions from Plan 01 baseline)
- Failed calculations do NOT add to history
</success_criteria>

<output>
After completion, create `.planning/phases/03-advanced-modes-history/03-02-SUMMARY.md`
</output>
