---
phase: 02-scientific-functions-basic-gui
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/calculator/ui/calculator_window.py
  - src/calculator/ui/display.py
  - src/calculator/ui/button_panel.py
  - src/calculator/controller/calculator_controller.py
  - src/calculator/config/locale.py
  - src/calculator/config/constants.py
  - src/calculator/main.py
  - tests/test_controller.py
autonomous: true

must_haves:
  truths:
    - "Running python -m calculator.main opens a CustomTkinter window with dark theme"
    - "User can click number buttons (0-9) and see digits appear on the display"
    - "User can click operator buttons (+, -, *, /) and function buttons (sin, cos, sqrt, etc.) to build expressions"
    - "User can click = to evaluate expression and see result on display"
    - "User can click C to clear expression and reset display to 0"
    - "Display shows both current expression (top line) and result (bottom line, larger font)"
    - "Window resizes proportionally -- buttons and display expand/shrink with window"
    - "Basic mode shows digits, operators, parentheses, decimal, clear, backspace, equals in clean 5-row grid"
    - "Scientific mode adds a row of function buttons (sin, cos, tan, sqrt, log, ln, x^y, n!, pi, e)"
    - "All button labels and window title are in Polish"
    - "Buttons have rounded corners (corner_radius >= 8) and dark theme styling"
  artifacts:
    - path: "src/calculator/ui/calculator_window.py"
      provides: "Main CTk window with dark theme, grid layout, display and button panel"
      contains: "class CalculatorWindow"
    - path: "src/calculator/ui/display.py"
      provides: "Display panel with expression label and result label using StringVar"
      contains: "class DisplayPanel"
    - path: "src/calculator/ui/button_panel.py"
      provides: "Button grid with basic and scientific layouts, rounded CTkButtons"
      contains: "class ButtonPanel"
    - path: "src/calculator/controller/calculator_controller.py"
      provides: "Controller mediating UI events to CalculatorEngine operations"
      contains: "class CalculatorController"
    - path: "src/calculator/main.py"
      provides: "Application entry point launching GUI via controller"
      contains: "CalculatorController"
    - path: "src/calculator/config/locale.py"
      provides: "Polish button labels and window title"
      contains: "BTN_"
    - path: "tests/test_controller.py"
      provides: "Controller unit tests with mocked view"
      contains: "class TestCalculatorController"
  key_links:
    - from: "src/calculator/controller/calculator_controller.py"
      to: "src/calculator/logic/calculator.py"
      via: "self.engine = CalculatorEngine() and self.engine.calculate()"
      pattern: "self\\.engine\\.calculate"
    - from: "src/calculator/controller/calculator_controller.py"
      to: "src/calculator/ui/calculator_window.py"
      via: "self.view = CalculatorWindow() and callback binding"
      pattern: "self\\.view"
    - from: "src/calculator/ui/button_panel.py"
      to: "src/calculator/controller/calculator_controller.py"
      via: "on_button_click callback set by controller"
      pattern: "self\\.callback"
    - from: "src/calculator/ui/display.py"
      to: "controller"
      via: "StringVar updates from controller calling update_expression/update_result"
      pattern: "StringVar"
    - from: "src/calculator/main.py"
      to: "src/calculator/controller/calculator_controller.py"
      via: "imports and calls CalculatorController().run()"
      pattern: "CalculatorController.*run"
---

<objective>
Build the complete CustomTkinter GUI with dark theme, responsive grid layout, display panel, button panels for basic and scientific modes, and MVC controller wiring everything to the Phase 1+Plan 01 calculation engine.

Purpose: Deliver the visual calculator interface (UI-01 through UI-05, MODE-01 through MODE-03) so users can interact with the scientific calculation engine through buttons and a display rather than CLI. This transforms SciCalc from a backend library into a usable desktop application.

Output: Four new modules (calculator_window.py, display.py, button_panel.py, calculator_controller.py), extended locale.py with button labels, updated main.py as GUI entry point, and controller tests with mocked view.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scientific-functions-basic-gui/02-RESEARCH.md
@.planning/phases/02-scientific-functions-basic-gui/02-01-SUMMARY.md
@src/calculator/logic/calculator.py
@src/calculator/logic/evaluator.py
@src/calculator/config/locale.py
@src/calculator/config/constants.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UI components (window, display, button panel) and extend config</name>
  <files>
    src/calculator/ui/calculator_window.py
    src/calculator/ui/display.py
    src/calculator/ui/button_panel.py
    src/calculator/config/locale.py
    src/calculator/config/constants.py
  </files>
  <action>
    **1. Extend `src/calculator/config/locale.py`** -- Add Polish button labels and window title. Append to the existing file (do NOT modify existing strings):

    ```python
    # Window
    WINDOW_TITLE = "SciCalc - Kalkulator Naukowy"

    # Button labels (Polish where applicable)
    BTN_CLEAR = "C"
    BTN_BACKSPACE = "\u232b"  # Unicode backspace symbol
    BTN_EQUALS = "="
    BTN_DECIMAL = "."
    BTN_OPEN_PAREN = "("
    BTN_CLOSE_PAREN = ")"
    BTN_POWER = "x^y"
    BTN_FACTORIAL = "n!"
    BTN_SQRT = "\u221a"  # Square root symbol for display
    BTN_NEGATE = "+/-"

    # Mode labels
    BTN_MODE_BASIC = "Podstawowy"
    BTN_MODE_SCIENTIFIC = "Naukowy"
    ```

    Note: WINDOW_TITLE may already exist from Phase 1 as `"Kalkulator Naukowy"` -- update it to `"SciCalc - Kalkulator Naukowy"` to include the app name, or keep existing if identical.

    **2. Extend `src/calculator/config/constants.py`** -- Add UI layout constants. Append to existing file:

    ```python
    # UI Constants
    WINDOW_MIN_WIDTH = 380
    WINDOW_MIN_HEIGHT = 520
    WINDOW_DEFAULT_GEOMETRY = "400x600"

    # Font sizes
    FONT_EXPRESSION = 16
    FONT_RESULT = 32
    FONT_BUTTON = 18

    # Button styling
    BUTTON_CORNER_RADIUS = 10
    BUTTON_PADDING = 4

    # Button layout for basic mode (5 rows x 4 columns)
    BASIC_LAYOUT = [
        ["C", "\u232b", "(", ")"],
        ["7", "8", "9", "/"],
        ["4", "5", "6", "*"],
        ["1", "2", "3", "-"],
        ["0", ".", "=", "+"],
    ]

    # Additional row for scientific mode (prepended above basic layout)
    SCIENTIFIC_ROW_1 = ["sin", "cos", "tan", "\u221a"]
    SCIENTIFIC_ROW_2 = ["log", "ln", "x^y", "n!"]
    SCIENTIFIC_ROW_3 = ["\u03c0", "e", "(", ")"]

    # Color scheme for button types (dark theme)
    BUTTON_COLORS = {
        "number": {"fg_color": "#2B2B2B", "hover_color": "#3B3B3B", "text_color": "white"},
        "operator": {"fg_color": "#FF9500", "hover_color": "#FFB340", "text_color": "white"},
        "function": {"fg_color": "#505050", "hover_color": "#606060", "text_color": "white"},
        "action": {"fg_color": "#D4D4D2", "hover_color": "#E4E4E2", "text_color": "black"},
        "equals": {"fg_color": "#FF9500", "hover_color": "#FFB340", "text_color": "white"},
    }
    ```

    **3. Create `src/calculator/ui/display.py`** -- Display panel component:

    ```python
    """Display panel showing current expression and calculation result."""
    import customtkinter as ctk
    from src.calculator.config.constants import FONT_EXPRESSION, FONT_RESULT

    class DisplayPanel(ctk.CTkFrame):
        """Two-line display: expression (top, smaller) and result (bottom, larger)."""

        def __init__(self, master):
            super().__init__(master, fg_color="transparent")

            # Configure grid
            self.grid_columnconfigure(0, weight=1)

            # Expression display (top line -- shows what user is typing)
            self.expression_var = ctk.StringVar(value="")
            self.expression_label = ctk.CTkLabel(
                self,
                textvariable=self.expression_var,
                font=("Helvetica", FONT_EXPRESSION),
                anchor="e",
                text_color="gray60"
            )
            self.expression_label.grid(row=0, column=0, sticky="ew", padx=10, pady=(10, 0))

            # Result display (bottom line -- shows result or "0")
            self.result_var = ctk.StringVar(value="0")
            self.result_label = ctk.CTkLabel(
                self,
                textvariable=self.result_var,
                font=("Helvetica", FONT_RESULT, "bold"),
                anchor="e",
                text_color="white"
            )
            self.result_label.grid(row=1, column=0, sticky="ew", padx=10, pady=(0, 10))

        def update_expression(self, text):
            """Update the expression display."""
            self.expression_var.set(text)

        def update_result(self, text):
            """Update the result display."""
            self.result_var.set(text)

        def show_error(self, error_text):
            """Show error in result display with error color."""
            self.result_var.set(error_text)
    ```

    **4. Create `src/calculator/ui/button_panel.py`** -- Button grid component:

    Create a ButtonPanel(CTkFrame) class that:

    a) Accepts `master`, `mode` ("basic" or "scientific"), and `callback` (function to call on button click).

    b) Has a `set_callback(self, callback)` method for the controller to bind its handler.

    c) Has a `set_mode(self, mode)` method that switches between basic and scientific layouts.

    d) Builds button grid in `_create_buttons(self)` method:
    - For basic mode: use BASIC_LAYOUT from constants (5 rows x 4 columns)
    - For scientific mode: prepend SCIENTIFIC_ROW_1 and SCIENTIFIC_ROW_2 above BASIC_LAYOUT (7 rows x 4 columns). Replace the BASIC_LAYOUT's first row parentheses with SCIENTIFIC_ROW_3 row for pi and e (or add as a row).
    - Each button: `ctk.CTkButton` with `corner_radius=BUTTON_CORNER_RADIUS`, proper sizing, and `command=lambda l=label: self._on_click(l)` (use default parameter to avoid closure bug from Research pitfall #4).
    - Apply BUTTON_COLORS based on button type: digits are "number", operators (+,-,*,/) are "operator", functions (sin,cos,etc) are "function", C and backspace are "action", = is "equals".
    - Set `grid_rowconfigure(row, weight=1)` and `grid_columnconfigure(col, weight=1)` for ALL rows and columns so buttons resize with window (Research pitfall #2).
    - Use `sticky="nsew"` on all buttons so they fill their grid cells.

    e) `_on_click(self, label)` method: Call `self.callback(label)` if callback is set.

    f) For mode switching, clear all existing buttons with `widget.destroy()` for all children, then rebuild. Use `grid_slaves()` or store button references in a list.

    g) Classify buttons with a helper `_get_button_type(self, label)`:
    - digits (0-9): "number"
    - operators (+, -, *, /): "operator"
    - functions (sin, cos, tan, sqrt/unicode, log, ln, x^y, n!, pi/unicode, e): "function"
    - actions (C, backspace/unicode): "action"
    - equals (=): "equals"
    - parentheses, decimal: "number"

    **5. Create `src/calculator/ui/calculator_window.py`** -- Main window:

    ```python
    """Main calculator window using CustomTkinter."""
    import customtkinter as ctk
    from src.calculator.config.constants import (
        WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT, WINDOW_DEFAULT_GEOMETRY
    )
    from src.calculator.config.locale import WINDOW_TITLE, BTN_MODE_BASIC, BTN_MODE_SCIENTIFIC
    from src.calculator.ui.display import DisplayPanel
    from src.calculator.ui.button_panel import ButtonPanel

    class CalculatorWindow(ctk.CTk):
        """Main calculator window with display and button panels."""

        def __init__(self):
            super().__init__()

            # Window configuration
            self.title(WINDOW_TITLE)
            self.geometry(WINDOW_DEFAULT_GEOMETRY)
            self.minsize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT)

            # Configure main grid: display (fixed height) + buttons (expandable)
            self.grid_columnconfigure(0, weight=1)
            self.grid_rowconfigure(0, weight=0)  # Mode toggle - fixed
            self.grid_rowconfigure(1, weight=0)  # Display - fixed
            self.grid_rowconfigure(2, weight=1)  # Buttons - expandable

            # Mode toggle (CTkSegmentedButton at top)
            self.mode_var = ctk.StringVar(value=BTN_MODE_BASIC)
            self.mode_toggle = ctk.CTkSegmentedButton(
                self,
                values=[BTN_MODE_BASIC, BTN_MODE_SCIENTIFIC],
                variable=self.mode_var,
                command=self._on_mode_change
            )
            self.mode_toggle.grid(row=0, column=0, padx=10, pady=(10, 5), sticky="ew")

            # Display panel
            self.display = DisplayPanel(self)
            self.display.grid(row=1, column=0, padx=10, pady=5, sticky="ew")

            # Button panel (starts in basic mode)
            self.buttons = ButtonPanel(self, mode="basic")
            self.buttons.grid(row=2, column=0, padx=10, pady=(5, 10), sticky="nsew")

            # Callback holders (set by controller)
            self._button_callback = None
            self._mode_callback = None

        def set_button_callback(self, callback):
            """Set the callback for button clicks (called by controller)."""
            self._button_callback = callback
            self.buttons.set_callback(callback)

        def set_mode_callback(self, callback):
            """Set the callback for mode changes (called by controller)."""
            self._mode_callback = callback

        def _on_mode_change(self, value):
            """Handle mode toggle change."""
            mode = "basic" if value == BTN_MODE_BASIC else "scientific"
            self.buttons.set_mode(mode)
            # Re-bind callback after mode change rebuilds buttons
            if self._button_callback:
                self.buttons.set_callback(self._button_callback)
            if self._mode_callback:
                self._mode_callback(mode)

        def update_expression(self, text):
            """Update expression display (convenience method)."""
            self.display.update_expression(text)

        def update_result(self, text):
            """Update result display (convenience method)."""
            self.display.update_result(text)

        def show_error(self, error_text):
            """Show error on display (convenience method)."""
            self.display.show_error(error_text)
    ```

    IMPORTANT: Call `ctk.set_appearance_mode("dark")` and `ctk.set_default_color_theme("blue")` BEFORE creating CalculatorWindow. This should be done at the module level or in main.py before instantiation (Research pitfall #3).
  </action>
  <verify>
    Verify all UI files are importable (without launching GUI):
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    import sys; sys.path.insert(0, 'src')
    from calculator.ui.display import DisplayPanel
    from calculator.ui.button_panel import ButtonPanel
    from calculator.ui.calculator_window import CalculatorWindow
    from calculator.config.locale import WINDOW_TITLE, BTN_CLEAR, BTN_MODE_BASIC
    from calculator.config.constants import BASIC_LAYOUT, BUTTON_COLORS, WINDOW_DEFAULT_GEOMETRY
    print('All UI imports OK')
    print('Window title:', WINDOW_TITLE)
    print('Basic layout rows:', len(BASIC_LAYOUT))
    print('Button color types:', list(BUTTON_COLORS.keys()))
    "
    ```
    Must print "All UI imports OK" without errors.

    Verify constants and locale have the new additions:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    import sys; sys.path.insert(0, 'src')
    from calculator.config.constants import BUTTON_CORNER_RADIUS, FONT_RESULT
    print('Corner radius:', BUTTON_CORNER_RADIUS)
    print('Result font size:', FONT_RESULT)
    "
    ```
  </verify>
  <done>
    Three UI components created: DisplayPanel (expression + result with StringVar), ButtonPanel (responsive grid with basic/scientific layouts, colored rounded buttons, mode switching), CalculatorWindow (main CTk window with dark theme, mode toggle, display, and buttons). Config extended with UI constants (layouts, colors, fonts, sizing) and Polish labels. All modules importable without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create controller, update main.py entry point, and write controller tests</name>
  <files>
    src/calculator/controller/calculator_controller.py
    src/calculator/main.py
    tests/test_controller.py
  </files>
  <action>
    **1. Create `src/calculator/controller/calculator_controller.py`** -- MVC controller:

    ```python
    """Calculator controller mediating between UI and CalculatorEngine."""
    import customtkinter as ctk
    from src.calculator.logic.calculator import CalculatorEngine
    from src.calculator.ui.calculator_window import CalculatorWindow
    from src.calculator.config.locale import BTN_MODE_BASIC

    class CalculatorController:
        """Controller binding CalculatorWindow events to CalculatorEngine operations."""

        def __init__(self):
            # Set appearance before creating window
            ctk.set_appearance_mode("dark")
            ctk.set_default_color_theme("blue")

            # Create model and view
            self.engine = CalculatorEngine()
            self.view = CalculatorWindow()
            self.current_expression = ""
            self.last_result = None
            self.has_error = False

            # Bind callbacks
            self.view.set_button_callback(self.on_button_click)
            self.view.set_mode_callback(self.on_mode_change)

        def on_button_click(self, label):
            """Route button clicks to appropriate handler."""
            # Map display labels to expression tokens
            LABEL_TO_TOKEN = {
                "\u221a": "sqrt(",      # sqrt symbol -> function call
                "x^y": "^",             # power button -> ^ operator
                "n!": "factorial(",     # factorial button -> function call
                "\u03c0": "pi",         # pi symbol -> pi constant
                "\u232b": "BACKSPACE",  # backspace symbol
                "sin": "sin(",
                "cos": "cos(",
                "tan": "tan(",
                "log": "log(",
                "ln": "ln(",
            }

            token = LABEL_TO_TOKEN.get(label, label)

            if token == "=":
                self._calculate()
            elif token == "C":
                self._clear()
            elif token == "BACKSPACE":
                self._backspace()
            else:
                self._append(token)

        def on_mode_change(self, mode):
            """Handle mode switch between basic and scientific."""
            # Mode switch handled by view internally (button layout changes)
            # Controller just needs to know for potential future logic
            pass

        def _append(self, text):
            """Append text to current expression and update display."""
            # If previous operation resulted in error, clear first
            if self.has_error:
                self.current_expression = ""
                self.has_error = False

            self.current_expression += text
            self.view.update_expression(self.current_expression)

        def _calculate(self):
            """Evaluate current expression via CalculatorEngine."""
            if not self.current_expression:
                return

            result = self.engine.calculate(self.current_expression)

            if result["success"]:
                self.view.update_result(result["result"])
                self.last_result = result["result"]
                # Keep expression visible so user sees what was calculated
                self.has_error = False
            else:
                self.view.show_error(result["error"])
                self.has_error = True

        def _clear(self):
            """Clear expression and reset display."""
            self.current_expression = ""
            self.has_error = False
            self.view.update_expression("")
            self.view.update_result("0")

        def _backspace(self):
            """Remove last character from expression."""
            if self.has_error:
                self._clear()
                return

            self.current_expression = self.current_expression[:-1]
            self.view.update_expression(self.current_expression)

        def run(self):
            """Start the application main loop."""
            self.view.mainloop()
    ```

    Key design decisions:
    - Function buttons (sin, cos, etc.) append "sin(" -- the opening paren is included so user just needs to type the argument and closing paren. This matches standard calculator UX.
    - sqrt button uses unicode symbol on display but maps to "sqrt(" in expression.
    - x^y button maps to "^" operator (which Plan 01 remapped from XOR to power).
    - n! button maps to "factorial(" function call.
    - pi symbol maps to "pi" constant name.
    - After error, next button press clears the error state.

    **2. Rewrite `src/calculator/main.py`** -- Replace the Phase 1 stub with GUI launcher:

    ```python
    """
    SciCalc - Kalkulator Naukowy
    Main entry point for the GUI application.
    """
    from src.calculator.controller.calculator_controller import CalculatorController


    def main():
        """Launch the SciCalc calculator GUI."""
        controller = CalculatorController()
        controller.run()


    if __name__ == "__main__":
        main()
    ```

    Keep it minimal. The controller handles all initialization (setting dark theme, creating engine and view, binding callbacks).

    **3. Create `tests/test_controller.py`** -- Unit tests for controller logic using mocked view:

    Test the controller WITHOUT launching a GUI. Use `unittest.mock.Mock` for the view and `unittest.mock.patch` for CTk initialization.

    ```python
    """Tests for CalculatorController logic with mocked view."""
    import pytest
    from unittest.mock import Mock, patch, MagicMock

    class TestCalculatorController:
        """Test controller button handling and expression management."""

        def setup_method(self):
            """Create controller with mocked view (no GUI)."""
            # Patch CTk classes to avoid GUI creation
            with patch('src.calculator.controller.calculator_controller.ctk') as mock_ctk, \
                 patch('src.calculator.controller.calculator_controller.CalculatorWindow') as MockWindow:

                # Setup mock view
                self.mock_view = Mock()
                self.mock_view.set_button_callback = Mock()
                self.mock_view.set_mode_callback = Mock()
                self.mock_view.update_expression = Mock()
                self.mock_view.update_result = Mock()
                self.mock_view.show_error = Mock()
                MockWindow.return_value = self.mock_view

                from src.calculator.controller.calculator_controller import CalculatorController
                self.controller = CalculatorController()
                self.controller.view = self.mock_view

        def test_digit_appends_to_expression(self):
            """Clicking digit adds it to expression."""
            self.controller.on_button_click("5")
            assert self.controller.current_expression == "5"
            self.mock_view.update_expression.assert_called_with("5")

        def test_multiple_digits(self):
            """Clicking multiple digits builds number."""
            self.controller.on_button_click("1")
            self.controller.on_button_click("2")
            self.controller.on_button_click("3")
            assert self.controller.current_expression == "123"

        def test_operator_appends(self):
            """Clicking operator adds it."""
            self.controller.on_button_click("5")
            self.controller.on_button_click("+")
            self.controller.on_button_click("3")
            assert self.controller.current_expression == "5+3"

        def test_equals_calculates(self):
            """Clicking = evaluates expression."""
            self.controller.current_expression = "2+3"
            self.controller.on_button_click("=")
            self.mock_view.update_result.assert_called_once_with("5")

        def test_equals_error(self):
            """Clicking = on invalid expression shows error."""
            self.controller.current_expression = "2/0"
            self.controller.on_button_click("=")
            self.mock_view.show_error.assert_called_once()

        def test_clear_resets(self):
            """Clicking C clears expression and result."""
            self.controller.current_expression = "123"
            self.controller.on_button_click("C")
            assert self.controller.current_expression == ""
            self.mock_view.update_expression.assert_called_with("")
            self.mock_view.update_result.assert_called_with("0")

        def test_backspace_removes_last(self):
            """Clicking backspace removes last character."""
            self.controller.current_expression = "123"
            self.controller.on_button_click("\u232b")
            assert self.controller.current_expression == "12"
            self.mock_view.update_expression.assert_called_with("12")

        def test_sin_button_appends_function(self):
            """Clicking sin appends 'sin(' to expression."""
            self.controller.on_button_click("sin")
            assert self.controller.current_expression == "sin("

        def test_sqrt_button_maps_to_function(self):
            """Clicking sqrt symbol appends 'sqrt(' to expression."""
            self.controller.on_button_click("\u221a")
            assert self.controller.current_expression == "sqrt("

        def test_power_button_maps_to_caret(self):
            """Clicking x^y appends '^' to expression."""
            self.controller.on_button_click("x^y")
            assert self.controller.current_expression == "^"

        def test_factorial_button_maps_to_function(self):
            """Clicking n! appends 'factorial(' to expression."""
            self.controller.on_button_click("n!")
            assert self.controller.current_expression == "factorial("

        def test_pi_button_maps_to_constant(self):
            """Clicking pi symbol appends 'pi' to expression."""
            self.controller.on_button_click("\u03c0")
            assert self.controller.current_expression == "pi"

        def test_empty_equals_does_nothing(self):
            """Clicking = on empty expression does nothing."""
            self.controller.on_button_click("=")
            self.mock_view.update_result.assert_not_called()
            self.mock_view.show_error.assert_not_called()

        def test_error_then_digit_clears(self):
            """After error, typing digit clears error state."""
            self.controller.current_expression = "2/0"
            self.controller.on_button_click("=")  # triggers error
            self.controller.on_button_click("5")  # should clear and start fresh
            assert self.controller.current_expression == "5"

        def test_full_scientific_expression(self):
            """Build and evaluate sin(90) through button clicks."""
            self.controller.on_button_click("sin")   # appends "sin("
            self.controller.on_button_click("9")
            self.controller.on_button_click("0")
            self.controller.on_button_click(")")
            assert self.controller.current_expression == "sin(90)"
            self.controller.on_button_click("=")
            self.mock_view.update_result.assert_called_once_with("1")
    ```

    Adjust the patching to match the actual import structure. The key insight is that we patch the CalculatorWindow and ctk at the controller module level to prevent actual GUI creation, but we still use the REAL CalculatorEngine so we can test end-to-end calculation logic through the controller.

    IMPORTANT: The test setup is tricky with patching. An alternative simpler approach is to:
    1. Create the controller normally but patch only `ctk.set_appearance_mode`, `ctk.set_default_color_theme`, and `CalculatorWindow`
    2. Or create CalculatorController with dependency injection: accept optional engine and view params in __init__

    If dependency injection approach is cleaner (which it likely is), modify CalculatorController.__init__ to accept optional parameters:
    ```python
    def __init__(self, engine=None, view=None):
        if view is None:
            ctk.set_appearance_mode("dark")
            ctk.set_default_color_theme("blue")
        self.engine = engine or CalculatorEngine()
        self.view = view or CalculatorWindow()
        ...
    ```
    This makes testing trivial -- pass Mock() as view and real CalculatorEngine as engine.
  </action>
  <verify>
    Run controller tests:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/test_controller.py -v --tb=short
    ```
    All controller tests must pass.

    Run full test suite (including all Phase 1 + Plan 01 tests):
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/ -v --tb=short
    ```
    ALL tests must pass (85+ from Plan 01 + 15+ controller tests = 100+ total).

    Verify GUI launches (manual smoke test):
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    import sys; sys.path.insert(0, 'src')
    from calculator.main import main
    print('main() is importable and ready')
    # Don't actually call main() in CI -- it blocks on mainloop()
    "
    ```

    Quick GUI launch test (will show window for 2 seconds then close):
    ```bash
    cd /Users/wojciecholszak/Desktop && timeout 3 python -c "
    import sys; sys.path.insert(0, 'src')
    import customtkinter as ctk
    ctk.set_appearance_mode('dark')
    from calculator.ui.calculator_window import CalculatorWindow
    win = CalculatorWindow()
    win.after(2000, win.destroy)
    win.mainloop()
    print('GUI launched and closed successfully')
    " 2>/dev/null || echo "GUI window created (timeout is expected)"
    ```
  </verify>
  <done>
    CalculatorController created with MVC pattern: binds button clicks to CalculatorEngine.calculate(), maps display labels to expression tokens (sin->sin(, sqrt symbol->sqrt(, x^y->^, n!->factorial(, pi symbol->pi), handles =, C, and backspace. main.py launches GUI via CalculatorController().run(). Controller tests verify digit input, operator input, function button mapping, calculation, error handling, clear, and backspace -- all with mocked view and real engine. Full test suite passes (100+ tests).
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `python -m pytest tests/ -v` -- ALL tests pass (100+ total)
2. Launch GUI: `cd src && python -m calculator.main` -- window opens in dark theme
3. Click number buttons -- digits appear on display
4. Click "sin" then "9" "0" ")" then "=" -- result shows "1"
5. Click "C" -- display resets to "0"
6. Click mode toggle to "Naukowy" -- additional function buttons appear
7. Click mode toggle to "Podstawowy" -- function buttons hidden, clean basic layout
8. Resize window -- buttons and display scale proportionally
9. All buttons have rounded corners and dark theme colors
10. Window title says "SciCalc - Kalkulator Naukowy"
11. Error from invalid expression shows Polish message on display
</verification>

<success_criteria>
- UI-01: Dark theme via CustomTkinter set_appearance_mode("dark")
- UI-02: Rounded buttons via corner_radius=10 on CTkButton
- UI-03: Polish interface (window title, mode labels from locale.py)
- UI-04: Responsive grid layout with weight configuration on all rows/columns
- UI-05: Display shows expression (top) and result (bottom) via StringVar
- MODE-01: Basic/scientific toggle via CTkSegmentedButton
- MODE-02: Basic mode shows only digits, operators, parentheses, clear, equals
- MODE-03: Scientific mode adds sin, cos, tan, sqrt, log, ln, power, factorial, pi, e buttons
- Controller tests pass with mocked view (no GUI dependency in tests)
- Full test suite passes (100+ tests, zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-scientific-functions-basic-gui/02-02-SUMMARY.md`
</output>
