---
phase: 02-scientific-functions-basic-gui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/calculator/logic/evaluator.py
  - src/calculator/logic/validator.py
  - src/calculator/logic/calculator.py
  - src/calculator/config/locale.py
  - src/calculator/config/constants.py
  - requirements.txt
  - tests/test_evaluator.py
  - tests/test_validator.py
  - tests/test_calculator.py
autonomous: true

must_haves:
  truths:
    - "sin(90) returns 1 in degrees mode and sin(pi/2) returns 1 in radians mode"
    - "cos(0) returns 1, tan(45) returns 1 in degrees mode"
    - "sqrt(4) returns 2, sqrt(9) returns 3"
    - "log(100) returns 2 (base-10), ln(e) returns 1 (natural log)"
    - "factorial(5) returns 120, factorial(0) returns 1"
    - "2^3 returns 8 (power operator remapped from XOR)"
    - "pi and e constants are available in expressions (pi returns 3.14159..., e returns 2.71828...)"
    - "Expressions with function names like sin(90) pass InputValidator without 'invalid expression' errors"
    - "factorial(5.5) and factorial(-1) return Polish error messages, not Python tracebacks"
  artifacts:
    - path: "src/calculator/logic/evaluator.py"
      provides: "SafeEvaluator with math functions, angle mode, and power operator"
      contains: "_build_functions"
    - path: "src/calculator/logic/validator.py"
      provides: "InputValidator extended to allow function names, ^, and pi/e constants"
      contains: "BASIC_FUNCTIONS"
    - path: "src/calculator/logic/calculator.py"
      provides: "CalculatorEngine with angle mode passthrough to evaluator"
      contains: "set_angle_mode"
    - path: "src/calculator/config/locale.py"
      provides: "Polish error messages for factorial and math domain errors"
      contains: "ERROR_FACTORIAL"
    - path: "src/calculator/config/constants.py"
      provides: "BASIC_FUNCTIONS list and MATH_CONSTANTS dict (already exists, verify unchanged)"
      contains: "BASIC_FUNCTIONS"
    - path: "requirements.txt"
      provides: "customtkinter dependency added alongside simpleeval"
      contains: "customtkinter"
  key_links:
    - from: "src/calculator/logic/evaluator.py"
      to: "simpleeval"
      via: "simple_eval(expression, functions=self.functions, names=self.names)"
      pattern: "simple_eval.*functions.*names"
    - from: "src/calculator/logic/evaluator.py"
      to: "math module"
      via: "angle-aware wrapper functions for sin/cos/tan"
      pattern: "math\\.sin|math\\.cos|math\\.tan"
    - from: "src/calculator/logic/validator.py"
      to: "src/calculator/config/constants.py"
      via: "imports BASIC_FUNCTIONS and ALL_FUNCTIONS for allowed function names"
      pattern: "from.*constants import.*FUNCTIONS"
    - from: "src/calculator/logic/calculator.py"
      to: "src/calculator/logic/evaluator.py"
      via: "delegates angle mode changes to evaluator.set_angle_mode()"
      pattern: "self\\.evaluator\\.set_angle_mode"
---

<objective>
Extend the Phase 1 calculation engine with all scientific mathematical functions: trigonometric (sin, cos, tan with angle mode), logarithmic (ln, log10), square root, exponentiation (^ operator), factorial, and mathematical constants (pi, e).

Purpose: Deliver the complete calculation backend (CALC-03 through CALC-07) that the GUI (Plan 02) will wire up to buttons. Without working scientific functions, the GUI would be a cosmetic shell with no math capability.

Output: Extended SafeEvaluator with 8+ math functions and angle mode support, extended InputValidator accepting function names and ^, updated CalculatorEngine with angle mode control, new Polish error messages, customtkinter in requirements.txt, and comprehensive tests covering all scientific operations.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scientific-functions-basic-gui/02-RESEARCH.md
@src/calculator/logic/evaluator.py
@src/calculator/logic/validator.py
@src/calculator/logic/calculator.py
@src/calculator/config/constants.py
@src/calculator/config/locale.py
@tests/test_evaluator.py
@tests/test_validator.py
@tests/test_calculator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SafeEvaluator with scientific functions, angle mode, and power operator</name>
  <files>
    src/calculator/logic/evaluator.py
    src/calculator/config/locale.py
    src/calculator/config/constants.py
  </files>
  <action>
    **1. Extend `src/calculator/config/locale.py`** -- Add new Polish error messages needed by scientific functions:

    ```python
    # Factorial errors
    ERROR_FACTORIAL_NOT_INTEGER = "Silnia wymaga liczby calkowitej"
    ERROR_FACTORIAL_NEGATIVE = "Silnia nie jest zdefiniowana dla liczb ujemnych"
    ERROR_FACTORIAL_TOO_LARGE = "Silnia: liczba zbyt duza (max 170)"
    ```

    Keep ALL existing strings untouched. Only ADD the new ones at the end of the error messages section.

    **2. Verify `src/calculator/config/constants.py`** -- It already has BASIC_FUNCTIONS, ALL_FUNCTIONS, MATH_CONSTANTS, ANGLE_MODE_* constants. Add `factorial` to BASIC_FUNCTIONS if not present (currently it is NOT in the list -- the list has: sin, cos, tan, sqrt, log, ln, abs). Add it:

    ```python
    BASIC_FUNCTIONS = ['sin', 'cos', 'tan', 'sqrt', 'log', 'ln', 'abs', 'factorial']
    ```

    Also add `'factorial'` to the BASIC_FUNCTIONS list. Do NOT change ALL_FUNCTIONS as it auto-derives from BASIC_FUNCTIONS + ADVANCED_FUNCTIONS. Also add a max factorial guard constant:

    ```python
    MAX_FACTORIAL_INPUT = 170  # math.factorial(171) overflows float
    ```

    **3. Rewrite `src/calculator/logic/evaluator.py`** -- Major extension. The current evaluator calls bare `simple_eval(expression)` with NO functions, NO names, NO operator remapping. Replace with:

    a) **Import additions:** Add `import math`, `import ast`, and `from simpleeval import SimpleEval, DEFAULT_FUNCTIONS, safe_power` (switch from simple_eval function to SimpleEval class for operator remapping).

    b) **`__init__` method:** Initialize angle_mode (default: "degrees" from constants.py DEFAULT_ANGLE_MODE). Call `self._build_functions()` to create function dict. Call `self._build_names()` for constants. Create a `SimpleEval` instance with functions, names, and operator remapping.

    ```python
    def __init__(self, angle_mode=None):
        from src.calculator.config.constants import DEFAULT_ANGLE_MODE, MATH_CONSTANTS
        self.angle_mode = angle_mode or DEFAULT_ANGLE_MODE
        self.names = dict(MATH_CONSTANTS)  # {"pi": 3.14159..., "e": 2.71828...}
        self.functions = self._build_functions()
        self._evaluator = self._build_evaluator()
    ```

    c) **`_build_functions` method:** Create function dict using `DEFAULT_FUNCTIONS.copy()` then `.update()` with:
    - `"sin"`: lambda wrapping `math.sin(self._to_radians(x))`
    - `"cos"`: lambda wrapping `math.cos(self._to_radians(x))`
    - `"tan"`: lambda wrapping `math.tan(self._to_radians(x))`
    - `"sqrt"`: `math.sqrt`
    - `"log"`: `math.log10` (base-10 logarithm -- standard calculator convention)
    - `"ln"`: `math.log` (natural logarithm)
    - `"abs"`: `abs`
    - `"factorial"`: `self._safe_factorial` (wrapper method, NOT raw math.factorial)

    d) **`_build_evaluator` method:** Create and return a `SimpleEval` instance:
    ```python
    def _build_evaluator(self):
        s = SimpleEval()
        s.functions = self.functions
        s.names = self.names
        s.operators[ast.BitXor] = safe_power  # Remap ^ to power
        return s
    ```

    e) **`_to_radians` method:** Convert angle based on self.angle_mode:
    - "degrees": `math.radians(angle)`
    - "radians": return angle unchanged
    - "gradians": `angle * math.pi / 200`
    - Else: raise ValueError with ERROR_INVALID_ANGLE_MODE

    f) **`_safe_factorial` method:** Validate before calling math.factorial:
    - If float and `.is_integer()`: convert to int
    - If not int: raise ValueError(ERROR_FACTORIAL_NOT_INTEGER)
    - If n < 0: raise ValueError(ERROR_FACTORIAL_NEGATIVE)
    - If n > 170: raise ValueError(ERROR_FACTORIAL_TOO_LARGE)
    - Return math.factorial(n)

    g) **`set_angle_mode` method:** Set self.angle_mode, rebuild functions dict AND rebuild evaluator. This avoids stale closure bugs (Research pitfall #1).

    ```python
    def set_angle_mode(self, mode):
        self.angle_mode = mode
        self.functions = self._build_functions()
        self._evaluator = self._build_evaluator()
    ```

    h) **`evaluate` method:** Replace `simple_eval(expression)` with `self._evaluator.eval(expression)`. Keep the same return dict structure `{"success": bool, "result": Decimal|None, "error": str|None}`. Add new except clauses:
    - `ValueError` -- catch factorial validation errors and math domain errors (e.g., sqrt(-1), log(-1)). Return the ValueError message as the error string if it's one of our custom messages, otherwise return ERROR_MATH_DOMAIN.
    - `OverflowError` -- return ERROR_OVERFLOW

    IMPORTANT: Keep the existing Decimal conversion: `Decimal(str(round(result, 10)))` for float-to-Decimal bridge from Phase 1 decision. Handle factorial results which may be very large integers -- for those, use `Decimal(result)` directly (no rounding needed for ints).

    ```python
    # In evaluate() result conversion:
    if isinstance(result, int):
        decimal_result = Decimal(result)
    else:
        decimal_result = Decimal(str(round(result, 10)))
    ```
  </action>
  <verify>
    Run existing tests to confirm no regressions:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/test_evaluator.py -v
    ```
    All 18 existing evaluator tests must still pass.

    Quick smoke test of new functions:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    import sys; sys.path.insert(0, 'src')
    from calculator.logic.evaluator import SafeEvaluator
    e = SafeEvaluator()
    print('sin(90):', e.evaluate('sin(90)'))
    print('sqrt(4):', e.evaluate('sqrt(4)'))
    print('log(100):', e.evaluate('log(100)'))
    print('2^3:', e.evaluate('2^3'))
    print('factorial(5):', e.evaluate('factorial(5)'))
    print('pi:', e.evaluate('pi'))
    "
    ```
    Expected: sin(90) result ~1, sqrt(4) result 2, log(100) result 2, 2^3 result 8, factorial(5) result 120, pi result ~3.14159.
  </verify>
  <done>
    SafeEvaluator supports sin, cos, tan (angle-aware), sqrt, log, ln, factorial, abs functions. Power operator ^ works as exponentiation. Constants pi and e are available. Angle mode defaults to degrees and can be changed via set_angle_mode(). Factorial validates input and returns Polish error messages for invalid inputs. All 18 existing evaluator tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend InputValidator, update CalculatorEngine, add requirements, and write comprehensive tests</name>
  <files>
    src/calculator/logic/validator.py
    src/calculator/logic/calculator.py
    requirements.txt
    tests/test_evaluator.py
    tests/test_validator.py
    tests/test_calculator.py
  </files>
  <action>
    **1. Extend `src/calculator/logic/validator.py`** -- The current `_validate_syntax` method uses regex `r'^[\d+\-*/().eE\s]+$'` which rejects alphabetic characters needed for function names (sin, cos, etc.) and the ^ operator.

    a) Import ALL_FUNCTIONS from constants:
    ```python
    from src.calculator.config.constants import ALL_FUNCTIONS
    ```

    b) Replace the simple regex validation in `_validate_syntax` with a smarter approach:
    - The new regex must allow: digits, operators (+,-,*,/,^), parentheses, decimal points, whitespace, AND alphabetic characters (for function names and constants like pi, e).
    - New pattern: `r'^[\d+\-*/().eE\s\^a-zA-Z_]+$'`
    - Additionally, validate that any alphabetic word in the expression is either a known function name (from ALL_FUNCTIONS) or a known constant (pi, e). Extract words with `re.findall(r'[a-zA-Z_]+', expression)` and check each against the allowed set.
    - Build the allowed set: `allowed_words = set(ALL_FUNCTIONS) | {'pi', 'e', 'E'}` (E for scientific notation like 1e5).

    c) If an unrecognized word is found, return:
    ```python
    {"valid": False, "error": ERROR_UNDEFINED_FUNCTION, "position": None}
    ```
    Import ERROR_UNDEFINED_FUNCTION from locale.py (it already exists: "Blad: Niezdefiniowana funkcja").

    d) Also add ^ to the trailing operator check -- currently checks `if expr_no_space[-1] in '+-*/'`, extend to `'+-*/^'`.

    e) Update the consecutive operator check to include ^ in the operators list.

    IMPORTANT: Keep all existing validation logic (empty check, parentheses check). Only modify `_validate_syntax`.

    **2. Extend `src/calculator/logic/calculator.py`** -- Add angle mode passthrough:

    a) Add `set_angle_mode(self, mode)` method that delegates to `self.evaluator.set_angle_mode(mode)`:
    ```python
    def set_angle_mode(self, mode):
        """Set angle mode for trigonometric calculations."""
        self.evaluator.set_angle_mode(mode)
    ```

    b) Optionally store current angle mode as `self.angle_mode` for UI to query.

    c) No other changes needed to calculator.py -- the evaluate flow (validate -> evaluate -> format) stays the same.

    **3. Update `requirements.txt`** -- Add customtkinter dependency for Plan 02:
    ```
    # SciCalc Dependencies
    # Production dependencies
    simpleeval>=0.9.0
    customtkinter>=5.2.0
    ```

    **4. Extend `tests/test_evaluator.py`** -- Add tests for ALL new scientific functions. Add a new test class or extend the existing one. Tests to add:

    Trigonometric (degrees mode -- default):
    - `test_sin_0_degrees`: sin(0) == 0
    - `test_sin_90_degrees`: sin(90) == 1 (or very close, use approx)
    - `test_cos_0_degrees`: cos(0) == 1
    - `test_cos_90_degrees`: cos(90) == 0 (approx)
    - `test_tan_45_degrees`: tan(45) == 1 (approx)

    Trigonometric (radians mode):
    - `test_sin_pi_half_radians`: set_angle_mode("radians"), sin(1.5707963267948966) approx 1
    - `test_angle_mode_switch`: evaluate sin(90) in degrees (==1), switch to radians, sin(90) should NOT be 1

    Logarithmic:
    - `test_log_100`: log(100) == 2
    - `test_log_10`: log(10) == 1
    - `test_ln_e`: ln(2.718281828459045) approx 1
    - `test_ln_1`: ln(1) == 0

    Square root:
    - `test_sqrt_4`: sqrt(4) == 2
    - `test_sqrt_9`: sqrt(9) == 3
    - `test_sqrt_negative`: sqrt(-1) returns error (math domain)

    Power operator:
    - `test_power_2_3`: 2^3 == 8
    - `test_power_5_2`: 5^2 == 25
    - `test_power_10_0`: 10^0 == 1

    Factorial:
    - `test_factorial_5`: factorial(5) == 120
    - `test_factorial_0`: factorial(0) == 1
    - `test_factorial_negative`: factorial(-1) returns Polish error
    - `test_factorial_float`: factorial(5.5) returns Polish error
    - `test_factorial_float_integer`: factorial(5.0) == 120 (should work -- integer value)

    Constants:
    - `test_pi`: pi approx 3.14159
    - `test_e`: e approx 2.71828
    - `test_expression_with_pi`: sin(pi) approx 0 (in radians mode)

    Combined expressions:
    - `test_combined`: sqrt(4) + sin(90) == 3 (in degrees)
    - `test_nested`: sqrt(sin(90)^2 + cos(90)^2) approx 1 (Pythagorean identity)

    Use `pytest.approx(expected, abs=1e-9)` for floating point comparisons. Access result via `result["result"]` and convert to float for approx comparison.

    **5. Extend `tests/test_validator.py`** -- Add tests for function name acceptance:
    - `test_sin_expression_valid`: "sin(90)" is valid
    - `test_cos_expression_valid`: "cos(0)" is valid
    - `test_sqrt_expression_valid`: "sqrt(4)" is valid
    - `test_log_expression_valid`: "log(100)" is valid
    - `test_factorial_expression_valid`: "factorial(5)" is valid
    - `test_power_operator_valid`: "2^3" is valid
    - `test_pi_constant_valid`: "pi" is valid
    - `test_e_constant_valid`: "e" is valid
    - `test_combined_expression_valid`: "sin(90) + sqrt(4)" is valid
    - `test_unknown_function_invalid`: "foo(5)" is invalid (undefined function)
    - `test_random_word_invalid`: "hello" is invalid (undefined)

    **6. Extend `tests/test_calculator.py`** -- Add integration tests through CalculatorEngine:
    - `test_scientific_sin`: engine.calculate("sin(90)") returns success with result "1"
    - `test_scientific_sqrt`: engine.calculate("sqrt(4)") returns success with result "2"
    - `test_scientific_power`: engine.calculate("2^3") returns success with result "8"
    - `test_scientific_factorial`: engine.calculate("factorial(5)") returns success with result "120"
    - `test_scientific_log`: engine.calculate("log(100)") returns success with result "2"
    - `test_angle_mode_change`: engine.set_angle_mode("radians"), verify trig results change
  </action>
  <verify>
    Run ALL tests:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -m pytest tests/ -v --tb=short
    ```
    ALL tests must pass -- both old (57 tests) and new (expect ~30+ new tests, total 85-90+).

    Verify customtkinter is installable:
    ```bash
    cd /Users/wojciecholszak/Desktop && pip install -r requirements.txt
    ```

    Verify validator accepts scientific expressions:
    ```bash
    cd /Users/wojciecholszak/Desktop && python -c "
    import sys; sys.path.insert(0, 'src')
    from calculator.logic.validator import InputValidator
    v = InputValidator()
    print('sin(90):', v.validate('sin(90)'))
    print('2^3:', v.validate('2^3'))
    print('foo(5):', v.validate('foo(5)'))
    "
    ```
    Expected: sin(90) valid, 2^3 valid, foo(5) invalid.
  </verify>
  <done>
    InputValidator accepts function names (sin, cos, tan, sqrt, log, ln, abs, factorial), ^ operator, and constants (pi, e). Rejects unknown function names with Polish error message. CalculatorEngine has set_angle_mode() method. requirements.txt includes customtkinter>=5.2.0. All tests pass (85+ tests including 30+ new scientific function tests covering trigonometric, logarithmic, square root, power, factorial, constants, and combined expressions).
  </done>
</task>

</tasks>

<verification>
1. Run full test suite: `python -m pytest tests/ -v` -- ALL tests pass (85+ total)
2. sin(90) returns 1 in default degrees mode
3. Switching to radians mode changes trig results (sin(90) != 1 in radians)
4. sqrt(4)=2, log(100)=2, ln(1)=0, factorial(5)=120
5. 2^3=8 (not XOR result of 1)
6. pi and e constants resolve to correct values
7. Validator accepts "sin(90)", "2^3", "pi" but rejects "foo(5)"
8. factorial(-1) and factorial(5.5) return Polish error messages
9. All 57 original Phase 1 tests still pass (no regressions)
10. requirements.txt contains both simpleeval and customtkinter
</verification>

<success_criteria>
- CALC-03: Trigonometric functions work (sin, cos, tan) with angle mode awareness
- CALC-04: Square root works (sqrt)
- CALC-05: Exponentiation works via ^ operator
- CALC-06: Logarithms work (log for base-10, ln for natural)
- CALC-07: Factorial works with proper validation
- All Phase 1 tests pass without modification (no regressions)
- 30+ new tests covering every scientific function and edge case
- customtkinter added to requirements.txt (ready for Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/02-scientific-functions-basic-gui/02-01-SUMMARY.md`
</output>
