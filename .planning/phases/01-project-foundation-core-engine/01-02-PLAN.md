---
phase: 01-project-foundation-core-engine
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/calculator/logic/evaluator.py
  - src/calculator/logic/validator.py
  - src/calculator/logic/calculator.py
  - tests/__init__.py
  - tests/test_evaluator.py
  - tests/test_validator.py
  - tests/test_calculator.py
autonomous: true

must_haves:
  truths:
    - "User can execute basic arithmetic: 2+3=5, 10-4=6, 3*7=21, 8/2=4"
    - "User can use parentheses: (2+3)*4=20, ((1+2)*(3+4))=21"
    - "Expressions are parsed safely without eval() — simpleeval used"
    - "Calculations use Decimal precision: 0.1+0.2=0.3 exactly"
    - "Division by zero shows Polish error: Nie mozna dzielic przez zero"
    - "Unbalanced parentheses show Polish error with position info"
    - "Empty expression shows Polish error: Wyrazenie jest puste"
  artifacts:
    - path: "src/calculator/logic/evaluator.py"
      provides: "SafeEvaluator class wrapping simpleeval"
      exports: ["SafeEvaluator"]
      contains: "simple_eval"
    - path: "src/calculator/logic/validator.py"
      provides: "InputValidator with parentheses and syntax validation"
      exports: ["InputValidator"]
      contains: "validate_parentheses"
    - path: "src/calculator/logic/calculator.py"
      provides: "CalculatorEngine orchestrating validator + evaluator"
      exports: ["CalculatorEngine"]
      contains: "Decimal"
    - path: "tests/test_evaluator.py"
      provides: "Tests for SafeEvaluator"
      contains: "def test_"
    - path: "tests/test_validator.py"
      provides: "Tests for InputValidator"
      contains: "def test_"
    - path: "tests/test_calculator.py"
      provides: "Tests for CalculatorEngine integration"
      contains: "def test_"
  key_links:
    - from: "src/calculator/logic/calculator.py"
      to: "src/calculator/logic/evaluator.py"
      via: "CalculatorEngine uses SafeEvaluator"
      pattern: "SafeEvaluator"
    - from: "src/calculator/logic/calculator.py"
      to: "src/calculator/logic/validator.py"
      via: "CalculatorEngine uses InputValidator"
      pattern: "InputValidator"
    - from: "src/calculator/logic/evaluator.py"
      to: "simpleeval"
      via: "SafeEvaluator wraps simple_eval"
      pattern: "simple_eval"
    - from: "src/calculator/logic/evaluator.py"
      to: "src/calculator/config/locale.py"
      via: "Polish error messages"
      pattern: "from.*config\\.locale import"
---

<objective>
Build the core calculation engine using TDD: SafeEvaluator (safe expression parsing with simpleeval), InputValidator (parentheses and syntax validation), and CalculatorEngine (orchestrator with Decimal precision).

Purpose: Deliver the critical Phase 1 functionality — correct, safe, precise arithmetic with clear Polish error messages. This is the heart of the calculator: CALC-01 (basic ops), CALC-02 (parentheses), CALC-08 (safe parser), CALC-09 (Decimal), CALC-10 (Polish errors).

Output: Three tested logic modules and their test suites, all passing.
</objective>

<execution_context>
@/Users/wojciecholszak/.claude/get-shit-done/workflows/execute-plan.md
@/Users/wojciecholszak/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-foundation-core-engine/01-RESEARCH.md
@.planning/phases/01-project-foundation-core-engine/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED - Write failing tests for all three modules</name>
  <files>
    tests/__init__.py
    tests/test_validator.py
    tests/test_evaluator.py
    tests/test_calculator.py
  </files>
  <action>
    First, install dependencies: `pip install simpleeval pytest`

    Create `tests/__init__.py` (empty).

    Write comprehensive test suites BEFORE implementing any logic. All tests must FAIL on first run.

    **`tests/test_validator.py`** — Test InputValidator:
    ```python
    import pytest
    import sys
    sys.path.insert(0, "src")
    from calculator.logic.validator import InputValidator

    @pytest.fixture
    def validator():
        return InputValidator()

    class TestParenthesesValidation:
        def test_balanced_parentheses(self, validator):
            valid, msg = validator.validate("(2+3)")
            assert valid is True

        def test_nested_parentheses(self, validator):
            valid, msg = validator.validate("((2+3)*(4+5))")
            assert valid is True

        def test_no_parentheses(self, validator):
            valid, msg = validator.validate("2+3")
            assert valid is True

        def test_missing_closing_paren(self, validator):
            valid, msg = validator.validate("(2+3")
            assert valid is False
            assert msg  # non-empty error

        def test_extra_closing_paren(self, validator):
            valid, msg = validator.validate("2+3)")
            assert valid is False

        def test_reversed_parens(self, validator):
            valid, msg = validator.validate(")(")
            assert valid is False

    class TestSyntaxValidation:
        def test_empty_expression(self, validator):
            valid, msg = validator.validate("")
            assert valid is False

        def test_whitespace_only(self, validator):
            valid, msg = validator.validate("   ")
            assert valid is False

        def test_trailing_operator(self, validator):
            valid, msg = validator.validate("2+3+")
            assert valid is False

        def test_valid_expression(self, validator):
            valid, msg = validator.validate("2+3*4")
            assert valid is True

        def test_unary_minus_allowed(self, validator):
            # Unary minus at start should be allowed
            valid, msg = validator.validate("-5+3")
            assert valid is True
    ```

    **`tests/test_evaluator.py`** — Test SafeEvaluator:
    ```python
    import pytest
    from decimal import Decimal
    import sys
    sys.path.insert(0, "src")
    from calculator.logic.evaluator import SafeEvaluator

    @pytest.fixture
    def evaluator():
        return SafeEvaluator()

    class TestBasicArithmetic:
        def test_addition(self, evaluator):
            assert evaluator.evaluate("2+3") == Decimal("5")

        def test_subtraction(self, evaluator):
            assert evaluator.evaluate("10-4") == Decimal("6")

        def test_multiplication(self, evaluator):
            assert evaluator.evaluate("3*7") == Decimal("21")

        def test_division(self, evaluator):
            assert evaluator.evaluate("8/2") == Decimal("4")

        def test_operator_precedence(self, evaluator):
            # 2+3*4 = 14 (NOT 20)
            assert evaluator.evaluate("2+3*4") == Decimal("14")

    class TestParentheses:
        def test_simple_parens(self, evaluator):
            assert evaluator.evaluate("(2+3)*4") == Decimal("20")

        def test_nested_parens(self, evaluator):
            assert evaluator.evaluate("((1+2)*(3+4))") == Decimal("21")

    class TestDecimalPrecision:
        def test_decimal_addition(self, evaluator):
            # THE critical test: 0.1+0.2 must equal 0.3
            result = evaluator.evaluate("0.1+0.2")
            assert result == Decimal("0.3")

        def test_decimal_subtraction(self, evaluator):
            result = evaluator.evaluate("0.3-0.1")
            assert result == Decimal("0.2")

    class TestErrorHandling:
        def test_division_by_zero(self, evaluator):
            with pytest.raises(ValueError, match="zero"):
                evaluator.evaluate("1/0")

        def test_invalid_expression(self, evaluator):
            with pytest.raises(ValueError):
                evaluator.evaluate("2++3")

        def test_no_eval_injection(self, evaluator):
            # Must NOT execute arbitrary Python
            with pytest.raises(ValueError):
                evaluator.evaluate("__import__('os').system('echo hacked')")
    ```

    **`tests/test_calculator.py`** — Test CalculatorEngine (integration):
    ```python
    import pytest
    import sys
    sys.path.insert(0, "src")
    from calculator.logic.calculator import CalculatorEngine

    @pytest.fixture
    def engine():
        return CalculatorEngine()

    class TestCalculate:
        def test_basic_addition(self, engine):
            assert engine.calculate("2+3") == "5"

        def test_decimal_precision(self, engine):
            # 0.1 + 0.2 must return "0.3" not "0.30000000000000004"
            assert engine.calculate("0.1+0.2") == "0.3"

        def test_parentheses(self, engine):
            assert engine.calculate("(2+3)*4") == "20"

        def test_complex_expression(self, engine):
            assert engine.calculate("2+3*4-1") == "13"

    class TestValidationIntegration:
        def test_empty_expression_error(self, engine):
            with pytest.raises(ValueError):
                engine.calculate("")

        def test_unbalanced_parens_error(self, engine):
            with pytest.raises(ValueError):
                engine.calculate("(2+3")

        def test_division_by_zero_error(self, engine):
            with pytest.raises(ValueError, match="zero"):
                engine.calculate("1/0")

    class TestFormatting:
        def test_integer_result(self, engine):
            # No trailing .0 for integer results
            result = engine.calculate("4+6")
            assert result == "10"

        def test_decimal_result(self, engine):
            result = engine.calculate("1/3")
            # Should be a decimal string, not crash
            assert "." in result or result.startswith("0")

        def test_trailing_zeros_removed(self, engine):
            result = engine.calculate("2.50+0.50")
            assert result == "3"
    ```

    Run: `cd /path/to/project && python -m pytest tests/ -v` — ALL tests must FAIL (ImportError since modules don't exist yet). This confirms RED phase.
  </action>
  <verify>
    Run: `python -m pytest tests/ -v 2>&1 | tail -5` — must show failures/errors (RED phase confirmed).
    Every test file must exist and be syntactically valid Python.
  </verify>
  <done>
    All test files written. Tests fail because implementation modules don't exist yet. RED phase complete.
  </done>
</task>

<task type="auto">
  <name>Task 2: GREEN - Implement SafeEvaluator, InputValidator, and CalculatorEngine</name>
  <files>
    src/calculator/logic/evaluator.py
    src/calculator/logic/validator.py
    src/calculator/logic/calculator.py
  </files>
  <action>
    Implement all three modules to make ALL tests pass. Follow the patterns from 01-RESEARCH.md exactly.

    **`src/calculator/logic/validator.py`** — InputValidator class:
    - `validate(expression: str) -> tuple[bool, str]` — Full validation pipeline
    - `validate_parentheses(expression: str) -> tuple[bool, str]` — Stack-based balanced parens check
    - `validate_syntax(expression: str) -> tuple[bool, str]` — Empty check, trailing operator check
    - Import error strings from `calculator.config.locale`
    - Unary minus at start of expression must be ALLOWED (not rejected as leading operator)
    - Return `(True, "")` for valid, `(False, "Polish error message")` for invalid

    **`src/calculator/logic/evaluator.py`** — SafeEvaluator class:
    - `evaluate(expression: str) -> Decimal` — Evaluate using simpleeval, return Decimal
    - Use `simple_eval()` from simpleeval library — NEVER eval()
    - Catch `ZeroDivisionError` -> raise `ValueError(ERROR_DIVISION_BY_ZERO)`
    - Catch `InvalidExpression` -> raise `ValueError(ERROR_INVALID_EXPRESSION)`
    - Catch generic `Exception` -> raise `ValueError(ERROR_CALCULATION + ": " + str(e))`
    - Convert result to Decimal via `Decimal(str(result))` for precision

    CRITICAL for Decimal precision test (0.1+0.2=0.3):
    simpleeval evaluates using float internally. `float(0.1) + float(0.2) = 0.30000000000000004`.
    Converting with `Decimal(str(0.30000000000000004))` gives `Decimal('0.30000000000000004')` which != `Decimal('0.3')`.

    Solution: After getting result from simpleeval, use `Decimal(str(result)).quantize(Decimal('1e-10')).normalize()` to trim float artifacts. OR use `round(result, 10)` before Decimal conversion. The approach: `Decimal(str(round(result, 10)))` handles the float->Decimal bridge for basic arithmetic.

    Alternative approach: Pre-process the expression to replace number literals with Decimal() calls and pass Decimal names to simpleeval's `names` parameter. This is more robust but more complex. For Phase 1, the round-then-convert approach is acceptable per research notes.

    **`src/calculator/logic/calculator.py`** — CalculatorEngine class:
    - `__init__()` — Create validator and evaluator instances, configure Decimal context (prec=28, ROUND_HALF_UP)
    - `calculate(expression: str) -> str` — Validate, evaluate, format result
    - `_format_result(value: Decimal) -> str` — Normalize Decimal, remove trailing zeros, handle scientific notation
    - Import from `calculator.config.constants` for precision settings
    - Validate FIRST (call validator), THEN evaluate (call evaluator)
    - If validator returns invalid, raise ValueError with the error message
    - Format: use `value.normalize()` to strip trailing zeros. If result is integer (no decimal part), display without decimal point.

    After implementing, run: `python -m pytest tests/ -v` — ALL tests must PASS.

    If any test fails, debug and fix the implementation. Do NOT modify tests (they define correct behavior).
  </action>
  <verify>
    Run: `python -m pytest tests/ -v` — ALL tests must pass (GREEN phase).
    Run: `python -c "import sys; sys.path.insert(0, 'src'); from calculator.logic.calculator import CalculatorEngine; e = CalculatorEngine(); print(e.calculate('0.1+0.2'))"` — must print exactly `0.3`.
    Run: `grep -r "eval(" src/calculator/logic/ | grep -v "simple_eval"` — must return EMPTY (no raw eval() usage).
  </verify>
  <done>
    All three modules implemented. All tests pass. 0.1+0.2=0.3 exactly. No eval() used. Polish error messages work. GREEN phase complete.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` — all tests pass
2. `python -c "...; print(e.calculate('0.1+0.2'))"` — prints "0.3"
3. `python -c "...; print(e.calculate('(2+3)*4'))"` — prints "20"
4. `python -c "...; print(e.calculate('2+3*4'))"` — prints "14" (operator precedence)
5. `grep -r "eval(" src/ | grep -v simple_eval` — empty (no raw eval)
6. Division by zero raises ValueError with Polish message containing "zero"
7. Unbalanced parentheses raise ValueError with Polish message
8. Empty expression raises ValueError with Polish message
</verification>

<success_criteria>
- SafeEvaluator correctly evaluates +, -, *, / with operator precedence (CALC-01)
- Parentheses work for grouping: (2+3)*4=20 (CALC-02)
- simpleeval used, NOT eval() (CALC-08)
- Decimal precision: 0.1+0.2 returns "0.3" exactly (CALC-09)
- Polish error messages for: division by zero, invalid expression, unbalanced parens, empty input (CALC-10)
- All tests pass with pytest
- CalculatorEngine integrates validator + evaluator correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation-core-engine/01-02-SUMMARY.md`
</output>
